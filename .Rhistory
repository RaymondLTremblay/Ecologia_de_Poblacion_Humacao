System[1+i,] <- doYear(System[i,])
}
##### LOTKA VOLTERRA PREDATION EXAMPLE
## Params
InitN1 <- 100
InitN2 <- 200
System1 <- data.frame(n1 = rep(InitN1,(Nyears*10+1)),n2 = InitN2)
## Do simulation
for(i in 1:(Nyears*10+1)){
System1[1+i,] <- doYear(System1[i,])
}
InitN1 <- 100
InitN2 <- 100
System2 <- data.frame(n1 = rep(InitN1,(Nyears*10+1)),n2 = InitN2)
## Do simulation
for(i in 1:(Nyears*10+1)){
System2[1+i,] <- doYear(System2[i,])
}
InitN1 <- 50
InitN2 <- 20
System3 <- data.frame(n1 = rep(InitN1,(Nyears*10+1)),n2 = InitN2)
## Do simulation
for(i in 1:(Nyears*10+1)){
System3[1+i,] <- doYear(System3[i,])
}
plot(1,1,pch="",xlim=xlim,ylim=ylim,xlab="Prey",ylab="Predators")
phasearrows.draw(new)
abline((r/Alpha),-(c/Alpha),col="red",lwd=3)   # prey
abline(v=q/Beta,col="blue",lwd=3)   # pred
points(jitter(System[,1],500),jitter(System[,2],500),col="brown",pch=20,cex=0.3)
points(jitter(System1[,1],500),jitter(System1[,2],500),col="green",pch=20,cex=0.3)
points(jitter(System2[,1],500),jitter(System2[,2],500),col="red",pch=20,cex=0.3)
points(jitter(System3[,1],500),jitter(System3[,2],500),col="blue",pch=20,cex=0.3)
plot(seq(1,100,length=nrow(System)), System[,1], xlab="Time", ylab="Abundance",type="l",col="orange",lwd=2,ylim=c(0,160),xlim=c(0,95))
points(seq(1,100,length=nrow(System)), System[,2], xlab="Time", ylab="Abundance",type="l",col="green",lwd=2,lty=2)
legend("top",lwd=c(2,2),lty=c(1,2),col=c("orange","green"),legend=c("prey","predator"),bty="n")
TypeIfuncresp <- function(V,alpha){
alpha*V
}
curve(TypeIfuncresp(x,0.1),0,500,xlab="Victim abundance",ylab="Total prey eaten per predator",col="red",lwd=3)
TypeIIfuncresp <- function(V,alpha,h){
(alpha*V)/(1+alpha*h*V)
}
curve(TypeIIfuncresp(x,0.1,0.1),0,500,xlab="Victim abundance",ylab="Total prey eaten per predator",col="red",lwd=3)
TypeIIIfuncresp <- function(V,alpha,h,k){
(alpha*V^k)/(1+alpha*h*V^k)
}
curve(TypeIIIfuncresp(x,0.0005,0.1,1.6),0,1000,xlab="Victim abundance",ylab="Total prey eaten per predator",col="red",lwd=3)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
TypeIIfuncresp <- function(V,alpha,h){
(alpha*V)/(1+alpha*h*V)
}
curve(TypeIIfuncresp(x,0.1,0.1),0,500,xlab="Victim abundance",ylab="Total prey eaten per predator",col="red",lwd=3)
TypeIIIfuncresp <- function(V,alpha,h,k){
(alpha*V^k)/(1+alpha*h*V^k)
}
curve(TypeIIIfuncresp(x,0.0005,0.1,1.6),0,1000,xlab="Victim abundance",ylab="Total prey eaten per predator",col="red",lwd=3)
getwd()
80+40+100+40+40+100
80/400
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('index.Rmd', 'word_document')
unlink('index_cache', recursive = TRUE)
rmarkdown::render('index.Rmd', 'word_document')
This is a classic example in population ecology, which we will revisit later in this course - but for now it serves as an example of an interacting system that exhibits an *emergent property*!
rmarkdown::render('index.Rmd', 'word_document')
rmarkdown::render('schedule.Rmd', 'word_document')
10*15
150/60
45/4
unlink('INTRO_cache', recursive = TRUE)
unlink('LAB1_cache', recursive = TRUE)
rmarkdown::render('LAB1.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LAB1.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LAB1.Rmd',rmarkdown::pdf_document())
getwd()
rmarkdown::render('LAB1.Rmd',rmarkdown::pdf_document())
unlink('LAB1_cache', recursive = TRUE)
rmarkdown::render('LAB1.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LAB1.Rmd',rmarkdown::pdf_document())
devtools::install_github('yihui/tinytex')
rmarkdown::render('LAB1.Rmd',rmarkdown::pdf_document())
rmarkdown::render('index.Rmd',rmarkdown::pdf_document())
rmarkdown::render('INTRO.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE1.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE2.Rmd',rmarkdown::pdf_document())  # latex_engine="xelatex"
rmarkdown::render('LAB1.Rmd',rmarkdown::pdf_document())
rmarkdown::render('INTRO.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE1.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE2.Rmd',rmarkdown::pdf_document())  # latex_engine="xelatex"
-log(0.00000001)
-log(0.01)
-log(10)
sin(0)
cos(0)
rmarkdown::render('LECTURE2.Rmd',rmarkdown::pdf_document())  # latex_engine="xelatex"
rmarkdown::render('LECTURE2.Rmd',rmarkdown::pdf_document())  # latex_engine="xelatex"
rmarkdown::render('LECTURE3.Rmd',rmarkdown::pdf_document())
install.packages(c("OpenStreetMap", "randomcoloR"))
To enable easy manipulation of these variables, change the **Show Value** Slider option of *Birth Rate* (in the properties window) to Yes.  Change the **Slider Max value** to 1, the **Slider Min value** to 0, and the **Slider Step value** to 0.01.  Do the same for *Death Rate* and *Population* (initial abundance $N_0$). For abundance, set the maximum value to 1000 and set the slider step size to 1 so we don't have fractional individuals! Now click on the white space of your model; you should now see the Birth Rate, Population and Death Rate sliders on the info tab. Change the slider values of the rates a few times, re-running the simulation each time. When you are confident that your model is working right, share it with your instructor and TA (save as a "public insight" and insert URL in the appropriate place in WebCampus).
rmarkdown::render('LAB1.Rmd',rmarkdown::pdf_document())
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('LAB3.Rmd',rmarkdown::pdf_document())
rmarkdown::render('FINAL_PROJECT.Rmd',rmarkdown::pdf_document())
rmarkdown::render('FINAL_PROJECTS.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE6.Rmd',rmarkdown::pdf_document())
unlink('LECTURE7_cache', recursive = TRUE)
rmarkdown::render('LECTURE7.Rmd',rmarkdown::pdf_document())
unlink('LAB4_cache', recursive = TRUE)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmd2rscript("LAB4.Rmd")  ##
rmarkdown::render('LAB4.Rmd',rmarkdown::pdf_document())
install.packages("deSolve")
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('LAB5.Rmd',rmarkdown::pdf_document())
unlink('LAB5_cache', recursive = TRUE)
rmarkdown::render('LAB5.Rmd',rmarkdown::pdf_document())
tinytex::tlmgr_update()
install.packages('tinytex')
tinytex::install_tinytex()
install.packages("tinytex")
rmarkdown::render('LAB5.Rmd',rmarkdown::pdf_document())
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('LAB5.Rmd',rmarkdown::pdf_document())
install.packages("marked")
install.packages("marked")
install.packages("marked")
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('LECTURE10.Rmd',rmarkdown::pdf_document())
unlink('LECTURE10_cache', recursive = TRUE)
unlink('LECTURE11_cache', recursive = TRUE)
rmarkdown::render('LECTURE10.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE11.Rmd',rmarkdown::pdf_document())
system("pandoc -v")
rmarkdown::render('LAB6.Rmd',rmarkdown::pdf_document())
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('schedule.Rmd',rmarkdown::pdf_document())
unlink('LECTURE12_cache', recursive = TRUE)
unlink('LECTURE12_cache', recursive = TRUE)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('LECTURE12.Rmd',rmarkdown::pdf_document())
rmd2rscript <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript_labanswers <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- c("answer","test")
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- grepl(input, pattern = stringToFind2[1], perl = TRUE) | grepl(input, pattern = stringToFind2[2])
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript("LECTURE12.Rmd")
rmarkdown::render('LECTURE12.Rmd',rmarkdown::pdf_document())
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
# plot a discrete distribution!
xvals <- seq(0,10,1)
probs <- dbinom(xvals,10,prob=0.3)
names(probs) <- xvals
barplot(probs,ylab="Probability",xlab="Possibilities",main="Binomial distribution (discrete)")
# plot a discrete distribution!
xvals <- seq(0,100,1)
probs <- dbinom(xvals,10,prob=0.2)
names(probs) <- xvals
barplot(probs,ylab="Probability",xlab="Total Deaths",main="Binomial distribution (total deaths)")
# plot a discrete distribution!
xvals <- seq(0,100,1)
probs <- dbinom(xvals,100,prob=0.2)
names(probs) <- xvals
barplot(probs,ylab="Probability",xlab="Total Deaths",main="Binomial distribution (total deaths)")
xvals <- seq(0,150,1)
probs <- dpois(xvals,lambda=0.9)
names(probs) <- xvals
barplot(probs,ylab="Probability",xlab="Total births",main="Poisson distribution (total births)")
xvals <- seq(0,150,1)
probs <- dpois(xvals,lambda=90)
names(probs) <- xvals
barplot(probs,ylab="Probability",xlab="Total births",main="Poisson distribution (total births)")
xvals <- seq(0,40,1)
probs <- dpois(xvals,lambda=9)
names(probs) <- xvals
barplot(probs,ylab="Probability",xlab="Total births",main="Poisson distribution (total births)")
xvals <- seq(0,140,1)
probs <- dpois(xvals,lambda=90)
names(probs) <- xvals
barplot(probs,ylab="Probability",xlab="Total births",main="Poisson distribution (total births)")
mean = 7.1
stdev = 2.1
curve(dnorm(x,mean,stdev),0,15,ylab="Probability (density)",xlab="Per-capita birth rate",main="Normal distribution (variation in vital rates)")   # probability density
unlink('PVA1_421_cache', recursive = TRUE)
unlink('PVA2_421_cache', recursive = TRUE)
unlink('PVA3_421_cache', recursive = TRUE)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('PVA1_421.Rmd',rmarkdown::pdf_document())
rmarkdown::render('PVA1_421.Rmd',rmarkdown::pdf_document())
rmarkdown::render('PVA2_421.Rmd',rmarkdown::pdf_document())
rmarkdown::render('PVA3_421.Rmd',rmarkdown::pdf_document())
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('PVA1_421.Rmd',rmarkdown::pdf_document())
unlink('PVA2_421_cache', recursive = TRUE)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('PVA1_421.Rmd',rmarkdown::pdf_document())
rmarkdown::render('PVA2_421.Rmd',rmarkdown::pdf_document())
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
# Run the matrix projection model!
nYears <- 100                                            # set the number of years to project
TMat <- projection_matrix                               # define the projection matrix
InitAbund <- Abundance_year0                            # define the initial abundance
## NOTE: the code below can be re-used without modification:
allYears <- matrix(0,nrow=nrow(TMat),ncol=nYears+1)     # build a storage array for all abundances!
allYears[,1] <- InitAbund  # set the year 0 abundance
for(t in 2:(nYears+1)){   # loop through all years
allYears[,t] <-  TMat %*% allYears[,t-1]
}
plot(1,1,pch="",ylim=c(0,max(allYears)),xlim=c(0,nYears+1),xlab="Years",ylab="Abundance",xaxt="n")  # set up blank plot
cols <- rainbow(5)    # set up colors to use
for(s in 1:5){
points(allYears[s,],col=cols[s],type="l",lwd=2)     # plot out each life stage abundance, one at a time
}
##### specify projection matrix!
projection_matrix <- matrix(
c(
0,     0,      0,      4.665,      61.896,
0.675, 0.703,  0,      0,          0,
0,     0.047,  0.657,  0,          0,
0,     0,      0.019,  0.682,      0,
0,     0,      0,      0.061,      0.809
)
,nrow=5,ncol=5,byrow=T
)
stagenames <- c("Hatchling","Small Juv","Large Juv","Subadult","Adult")
rownames(projection_matrix) <- stagenames
colnames(projection_matrix) <- stagenames
projection_matrix
# Run the matrix projection model!
nYears <- 100                                            # set the number of years to project
TMat <- projection_matrix                               # define the projection matrix
InitAbund <- Abundance_year0                            # define the initial abundance
## NOTE: the code below can be re-used without modification:
allYears <- matrix(0,nrow=nrow(TMat),ncol=nYears+1)     # build a storage array for all abundances!
allYears[,1] <- InitAbund  # set the year 0 abundance
Abundance_year0
# Run the matrix projection model!
nYears <- 100                                            # set the number of years to project
TMat <- projection_matrix                               # define the projection matrix
Abundance_year0 <- c(2000,500,300,300,20)   # vector of initial abundances
InitAbund <- Abundance_year0                            # define the initial abundance
## NOTE: the code below can be re-used without modification:
allYears <- matrix(0,nrow=nrow(TMat),ncol=nYears+1)     # build a storage array for all abundances!
allYears[,1] <- InitAbund  # set the year 0 abundance
for(t in 2:(nYears+1)){   # loop through all years
allYears[,t] <-  TMat %*% allYears[,t-1]
}
plot(1,1,pch="",ylim=c(0,max(allYears)),xlim=c(0,nYears+1),xlab="Years",ylab="Abundance",xaxt="n")  # set up blank plot
cols <- rainbow(5)    # set up colors to use
for(s in 1:5){
points(allYears[s,],col=cols[s],type="l",lwd=2)     # plot out each life stage abundance, one at a time
}
axis(1,at=seq(1,nYears+1),labels = seq(0,nYears))   # label the axis
legend("topright",col=cols,lwd=rep(2,3),legend=rownames(TMat),bty="n")  # put a legend on the plot
unlink('PVA3_421_cache', recursive = TRUE)
rmarkdown::render('PVA3_421.Rmd',rmarkdown::pdf_document())
unlink('LECTURE15_cache', recursive = TRUE)
unlink('LECTURE13_cache', recursive = TRUE)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('LECTURE13.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE13.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE13.Rmd',rmarkdown::pdf_document())
unlink('LAB6_cache', recursive = TRUE)
rmarkdown::render('LAB6.Rmd',rmarkdown::pdf_document())
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('LECTURE13.Rmd',rmarkdown::pdf_document())
unlink('LAB6_cache', recursive = TRUE)
rmarkdown::render('LAB6.Rmd',rmarkdown::pdf_document())
32*0.66
32*0.66*0.66
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
library(marked)
data(dipper)
dpr <- read.table('ed_males.txt',sep="",header=F)
names(dpr) <- c("ch","group")
head(dpr,15)
unlink('LAB7_cache', recursive = TRUE)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('LECTURE15.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE15.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LAB7.Rmd',rmarkdown::pdf_document())
library(marked)
data(dipper)
dpr <- read.table('ed_males.txt',sep="",header=F)
names(dpr) <- c("ch","group")
head(dpr,15)
unlink('LAB7_cache', recursive = TRUE)
rmarkdown::render('LAB7.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LAB7.Rmd',rmarkdown::pdf_document())
##########
# OPEN POPULATION MODELS
##########
library(marked)    # remember to install the 'marked' package if you haven't already done this
#?crm  # to get help on the main parameter estimation function in "marked"
# library(help="marked")
# vignette("markedVignette","marked")
##########
# load data!
data(dipper)
dipper.male <- dipper[which(dipper$sex=="Male"),]   # extract only the males, to compare with the Mark example
#############
# Process data
dipper.proc=process.data(dipper.male,model="cjs",begin.time=1)  # Helper function- process the data for CJS model
dipper.ddl=make.design.data(dipper.proc)    # another helper function- process data!
##########
# Fit models
########
# fit time-varying cjs model
mod.Phit.pt <- crm(dipper.proc,dipper.ddl,model.parameters=list(Phi=list(formula=~time),p=list(formula=~time)),method="Nelder-Mead",hessian = T)
mod.Phit.pt   # print out model
mod.Phit.pt$results$AIC       # extract AIC
########
# fit time-invariant cjs model
mod.Phidot.pdot <- crm(dipper.proc,dipper.ddl,model.parameters = list(Phi=list(formula=~1),p=list(formula=~1)),method="Nelder-Mead",hessian = TRUE)
mod.Phidot.pdot
mod.Phidot.pdot$results$AIC
###########
# compare all models with AIC
###########
######
# Set up models to run (must have either "Phi." or "p." in the name)
Phi.dot <- list(formula=~1)
Phi.time <- list(formula=~time)
p.dot <- list(formula=~1)
p.time <- list(formula=~time)
cml=create.model.list(c("Phi","p"))    # create list of all models to run
######
# Run all models
allmodels <- crm.wrapper(cml,data=dipper.proc, ddl=dipper.ddl,external=FALSE,accumulate=FALSE,method="Nelder-Mead",hessian=TRUE)
allmodels <- crm.wrapper(cml,data=dipper.proc, ddl=dipper.ddl,external=FALSE,accumulate=FALSE,method="Nelder-Mead",hessian=TRUE)
crm.wrapper
dipper.ddl
allmodels <- crm.wrapper(cml,data=dipper.proc, ddl=dipper.ddl,external=FALSE,accumulate=FALSE,method="Nelder-Mead",hessian=TRUE)
cml
cml
##########
# OPEN POPULATION MODELS
##########
library(marked)    # remember to install the 'marked' package if you haven't already done this
#?crm  # to get help on the main parameter estimation function in "marked"
# library(help="marked")
# vignette("markedVignette","marked")
##########
# load data!
data(dipper)
dipper.male <- dipper[which(dipper$sex=="Male"),]   # extract only the males, to compare with the Mark example
#############
# Process data
dipper.proc=process.data(dipper.male,model="cjs",begin.time=1)  # Helper function- process the data for CJS model
dipper.ddl=make.design.data(dipper.proc)    # another helper function- process data!
##########
# Fit models
########
# fit time-varying cjs model
mod.Phit.pt <- crm(dipper.proc,dipper.ddl,model.parameters=list(Phi=list(formula=~time),p=list(formula=~time)),method="Nelder-Mead",hessian = T)
mod.Phit.pt   # print out model
mod.Phit.pt$results$AIC       # extract AIC
########
# fit time-invariant cjs model
mod.Phidot.pdot <- crm(dipper.proc,dipper.ddl,model.parameters = list(Phi=list(formula=~1),p=list(formula=~1)),method="Nelder-Mead",hessian = TRUE)
mod.Phidot.pdot
mod.Phidot.pdot$results$AIC
###########
# compare all models with AIC
###########
######
# Set up models to run (must have either "Phi." or "p." in the name)
Phi.dot <- list(formula=~1)
Phi.time <- list(formula=~time)
p.dot <- list(formula=~1)
p.time <- list(formula=~time)
cml=create.model.list(c("Phi","p"))    # create list of all models to run
######
# Run all models
allmodels <- crm.wrapper(cml,data=dipper.proc, ddl=dipper.ddl,external=FALSE,accumulate=FALSE,method="Nelder-Mead",hessian=TRUE)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
############################################################
####                                                    ####
####  NRES 470/670, lab 7                               ####
####                                                    ####
####  Kevin Shoemaker                                   ####
####  University of Nevada, Reno                        ####
####                                                    ####
############################################################
############################################################
####  Parameter estimation                              ####
############################################################
##########
# CLOSED POPULATION MODELS
##########
# Note: I recommend doing these lab activities in EXCEL, but you're more than welcome to try to do it in R (instead of handing in your work as an excel spreadsheet, just hand in your R code!)
###########
# First, load up the CSV file (you need to download it first)
# setwd()     # remember to set your working directory before you read in the data!
head(read.csv("simple_closed.csv"))
##########
# OPEN POPULATION MODELS
##########
library(mra)   # remember to install the 'mra' package if you haven't already done this
data(dipper.histories)         # load up the data
head(dipper.histories,15)     # look at the top few lines
data(dipper.males)   # load up only the capture histories for male dippers!
library(marked)
data(dipper)
dpr <- read.table('ed_males.txt',sep="",header=F)
names(dpr) <- c("ch","group")
head(dpr,15)
##########
# OPEN POPULATION MODELS
##########
library(marked)    # remember to install the 'marked' package if you haven't already done this
#?crm  # to get help on the main parameter estimation function in "marked"
# library(help="marked")
# vignette("markedVignette","marked")
##########
# load data!
data(dipper)
dipper.male <- dipper[which(dipper$sex=="Male"),]   # extract only the males, to compare with the Mark example
#############
# Process data
dipper.proc=process.data(dipper.male,model="cjs",begin.time=1)  # Helper function- process the data for CJS model
dipper.ddl=make.design.data(dipper.proc)    # another helper function- process data!
##########
# Fit models
########
# fit time-varying cjs model
mod.Phit.pt <- crm(dipper.proc,dipper.ddl,model.parameters=list(Phi=list(formula=~time),p=list(formula=~time)),method="Nelder-Mead",hessian = T)
mod.Phit.pt   # print out model
mod.Phit.pt$results$AIC       # extract AIC
########
# fit time-invariant cjs model
mod.Phidot.pdot <- crm(dipper.proc,dipper.ddl,model.parameters = list(Phi=list(formula=~1),p=list(formula=~1)),method="Nelder-Mead",hessian = TRUE)
mod.Phidot.pdot
mod.Phidot.pdot$results$AIC
###########
# compare all models with AIC
###########
######
# Set up models to run (must have either "Phi." or "p." in the name)
Phi.dot <- list(formula=~1)
Phi.time <- list(formula=~time)
p.dot <- list(formula=~1)
p.time <- list(formula=~time)
cml=create.model.list(c("Phi","p"))    # create list of all models to run
######
# Run all models
allmodels <- crm.wrapper(cml,data=dipper.proc, ddl=dipper.ddl,external=FALSE,accumulate=FALSE,method="Nelder-Mead",hessian=TRUE)
allmodels
#######
# get parameter estimates and confidence intervals for best model
allmodels[[1]]
#######
# make predictions and plot them.
predict(allmodels[[1]])$Phi
Phi_by_year <- predict(allmodels[[3]])$Phi    # predict Phi for all years (based on the best Phi(t) model)
library(Hmisc)   #load Hmisc package- has a nice error bar function
plot(1:nrow(Phi_by_year),Phi_by_year$estimate,xlab="Year",ylab="Survival",ylim=c(0,1),main="Variability in Survival, dipper demo")
errbar(1:nrow(Phi_by_year),Phi_by_year$estimate,Phi_by_year$ucl,Phi_by_year$lcl,add=T)
unlink('LAB7_cache', recursive = TRUE)
rmarkdown::render('LAB7.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LAB7.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LAB7.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LAB7.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LAB7.Rmd',rmarkdown::pdf_document())
unlink('LECTURE14_cache', recursive = TRUE)
rmarkdown::render('LECTURE14.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE14.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE14.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE14.Rmd',rmarkdown::pdf_document())
