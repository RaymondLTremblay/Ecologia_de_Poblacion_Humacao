## toggle switch function for phase arrow and nullcline plotting
toggle = compiler::cmpfun(function(u,v,parms) {
c( u*parms[1]-parms[2]*u*v - parms[3]*u^2, parms[4]*u*v-parms[5]*v )
})
fun=toggle ## Our generic name for the system of equations to look at! ;-)
#
## toggle switch function for computing solution trajectories with deSolve::ode()
#Toggle = as.ode.func(toggle)
#
## parameter values?
Alpha <- 0.001
Beta <- 0.005
r <- 0.2
q <- 0.1
c <- 0.008
parms=c(r,Alpha,c,Beta,q)
# toggle(100,100,parms)
xlim = c(5,200)
ylim = c(5,200)
new <- phasearrows.calc(toggle,xlim,ylim,resol=25,parms=parms)
plot(1,1,pch="",xlim=xlim,ylim=ylim,xlab="Prey",ylab="Predators")
phasearrows.draw(new)
#
## END MODEL SPECIFICATION AND INITIALIZATION
#######################################################################################
plot(1,1,pch="",xlim=xlim,ylim=ylim,xlab="Prey",ylab="Predators")
phasearrows.draw(new)
abline((r/Alpha),-(c/Alpha),col="red",lwd=3)   # prey
abline(v=q/Beta,col="blue",lwd=3)   # pred
plot(seq(1:100,length=nrow(System)), System[,1], xlab="Time", ylab="Abundance")
plot(seq(1,100,length=nrow(System)), System[,1], xlab="Time", ylab="Abundance")
plot(seq(1,100,length=nrow(System)), System[,1], xlab="Time", ylab="Abundance",type="l",col="orange",lwd=2)
points(seq(1,100,length=nrow(System)), System[,2], xlab="Time", ylab="Abundance",type="l",col="green",lwd=2,lty=2)
plot(seq(1,100,length=nrow(System)), System[,1], xlab="Time", ylab="Abundance",type="l",col="orange",lwd=2,xlim=c(0,160))
points(seq(1,100,length=nrow(System)), System[,2], xlab="Time", ylab="Abundance",type="l",col="green",lwd=2,lty=2)
plot(seq(1,100,length=nrow(System)), System[,1], xlab="Time", ylab="Abundance",type="l",col="orange",lwd=2,ylim=c(0,160))
points(seq(1,100,length=nrow(System)), System[,2], xlab="Time", ylab="Abundance",type="l",col="green",lwd=2,lty=2)
plot(seq(1,100,length=nrow(System)), System[,1], xlab="Time", ylab="Abundance",type="l",col="orange",lwd=2,ylim=c(0,160),xlim=c(0,99))
points(seq(1,100,length=nrow(System)), System[,2], xlab="Time", ylab="Abundance",type="l",col="green",lwd=2,lty=2)
plot(seq(1,100,length=nrow(System)), System[,1], xlab="Time", ylab="Abundance",type="l",col="orange",lwd=2,ylim=c(0,160),xlim=c(0,95))
points(seq(1,100,length=nrow(System)), System[,2], xlab="Time", ylab="Abundance",type="l",col="green",lwd=2,lty=2)
plot(seq(1,100,length=nrow(System)), System[,1], xlab="Time", ylab="Abundance",type="l",col="orange",lwd=2,ylim=c(0,160),xlim=c(0,95))
points(seq(1,100,length=nrow(System)), System[,2], xlab="Time", ylab="Abundance",type="l",col="green",lwd=2,lty=2)
legend("topcenter",lwd=c(2,2),lty=c(1,2),col=c("orange","green"),legend=c("prey","predator"),bty="n")
plot(seq(1,100,length=nrow(System)), System[,1], xlab="Time", ylab="Abundance",type="l",col="orange",lwd=2,ylim=c(0,160),xlim=c(0,95))
points(seq(1,100,length=nrow(System)), System[,2], xlab="Time", ylab="Abundance",type="l",col="green",lwd=2,lty=2)
legend("top",lwd=c(2,2),lty=c(1,2),col=c("orange","green"),legend=c("prey","predator"),bty="n")
## Params
Alpha <- 0.001
Beta <- 0.005
r <- 0.2
q <- 0.1
c <- 0.008
InitPrey <- 100
InitPred <- 75
Nyears <- 100
step <- 0.1
System <- data.frame(prey = rep(InitPrey,(Nyears+1)*10),pred = InitPred)
doYear <- function(prevyear){
n1 <- prevyear[1] + r*prevyear[1]*step - Alpha*prevyear[1]*prevyear[2]*step - c*prevyear[1]^2
n2 <- prevyear[2] + Beta*prevyear[1]*prevyear[2]*step - q*prevyear[2]*step
return(c(n1,n2))
}
## Do simulation
for(i in 1:(Nyears*10+1)){
System[1+i,] <- doYear(System[i,])
}
##### LOTKA VOLTERRA PREDATION EXAMPLE
## Params
InitN1 <- 100
InitN2 <- 200
System1 <- data.frame(n1 = rep(InitN1,(Nyears*10+1)),n2 = InitN2)
## Do simulation
for(i in 1:(Nyears*10+1)){
System1[1+i,] <- doYear(System1[i,])
}
InitN1 <- 100
InitN2 <- 100
System2 <- data.frame(n1 = rep(InitN1,(Nyears*10+1)),n2 = InitN2)
## Do simulation
for(i in 1:(Nyears*10+1)){
System2[1+i,] <- doYear(System2[i,])
}
InitN1 <- 50
InitN2 <- 20
System3 <- data.frame(n1 = rep(InitN1,(Nyears*10+1)),n2 = InitN2)
## Do simulation
for(i in 1:(Nyears*10+1)){
System3[1+i,] <- doYear(System3[i,])
}
plot(1,1,pch="",xlim=xlim,ylim=ylim,xlab="Prey",ylab="Predators")
phasearrows.draw(new)
abline((r/Alpha),-(c/Alpha),col="red",lwd=3)   # prey
abline(v=q/Beta,col="blue",lwd=3)   # pred
points(jitter(System[,1],500),jitter(System[,2],500),col="brown",pch=20,cex=0.3)
points(jitter(System1[,1],500),jitter(System1[,2],500),col="green",pch=20,cex=0.3)
points(jitter(System2[,1],500),jitter(System2[,2],500),col="red",pch=20,cex=0.3)
points(jitter(System3[,1],500),jitter(System3[,2],500),col="blue",pch=20,cex=0.3)
System
System1
System2
## Params
Alpha <- 0.001
Beta <- 0.005
r <- 0.2
q <- 0.1
c <- 0.008
InitPrey <- 100
InitPred <- 75
Nyears <- 100
step <- 0.1
System <- data.frame(prey = rep(InitPrey,(Nyears+1)*10),pred = InitPred)
doYear <- function(prevyear){
n1 <- prevyear[1] + r*prevyear[1]*step - Alpha*prevyear[1]*prevyear[2]*step - c*prevyear[1]^2*step
n2 <- prevyear[2] + Beta*prevyear[1]*prevyear[2]*step - q*prevyear[2]*step
return(c(n1,n2))
}
## Do simulation
for(i in 1:(Nyears*10+1)){
System[1+i,] <- doYear(System[i,])
}
##### LOTKA VOLTERRA PREDATION EXAMPLE
## Params
InitN1 <- 100
InitN2 <- 200
System1 <- data.frame(n1 = rep(InitN1,(Nyears*10+1)),n2 = InitN2)
## Do simulation
for(i in 1:(Nyears*10+1)){
System1[1+i,] <- doYear(System1[i,])
}
InitN1 <- 100
InitN2 <- 100
System2 <- data.frame(n1 = rep(InitN1,(Nyears*10+1)),n2 = InitN2)
## Do simulation
for(i in 1:(Nyears*10+1)){
System2[1+i,] <- doYear(System2[i,])
}
InitN1 <- 50
InitN2 <- 20
System3 <- data.frame(n1 = rep(InitN1,(Nyears*10+1)),n2 = InitN2)
## Do simulation
for(i in 1:(Nyears*10+1)){
System3[1+i,] <- doYear(System3[i,])
}
plot(1,1,pch="",xlim=xlim,ylim=ylim,xlab="Prey",ylab="Predators")
phasearrows.draw(new)
abline((r/Alpha),-(c/Alpha),col="red",lwd=3)   # prey
abline(v=q/Beta,col="blue",lwd=3)   # pred
points(jitter(System[,1],500),jitter(System[,2],500),col="brown",pch=20,cex=0.3)
points(jitter(System1[,1],500),jitter(System1[,2],500),col="green",pch=20,cex=0.3)
points(jitter(System2[,1],500),jitter(System2[,2],500),col="red",pch=20,cex=0.3)
points(jitter(System3[,1],500),jitter(System3[,2],500),col="blue",pch=20,cex=0.3)
plot(seq(1,100,length=nrow(System)), System[,1], xlab="Time", ylab="Abundance",type="l",col="orange",lwd=2,ylim=c(0,160),xlim=c(0,95))
points(seq(1,100,length=nrow(System)), System[,2], xlab="Time", ylab="Abundance",type="l",col="green",lwd=2,lty=2)
legend("top",lwd=c(2,2),lty=c(1,2),col=c("orange","green"),legend=c("prey","predator"),bty="n")
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
LVfuncresp <- function(V,alpha){
alpha*V
}
curve(LVfuncresp(x,0.03),0,200,xlab="Victim abundance",ylab="Total prey eaten per predator",col="red",lwd=3)
TypeIfuncresp <- function(V,alpha){
alpha*V
}
curve(TypeIfuncresp(x,0.03),0,200,xlab="Victim abundance",ylab="Total prey eaten per predator",col="red",lwd=3)
TypeIIfuncresp <- function(V,alpha,h){
(alpha*V)/(1+alpha*h*V)
}
curve(TypeIIfuncresp(x,0.03,0.001),0,200,xlab="Victim abundance",ylab="Total prey eaten per predator",col="red",lwd=3)
TypeIIfuncresp <- function(V,alpha,h){
(alpha*V)/(1+alpha*h*V)
}
curve(TypeIIfuncresp(x,0.03,0.01),0,200,xlab="Victim abundance",ylab="Total prey eaten per predator",col="red",lwd=3)
TypeIIfuncresp <- function(V,alpha,h){
(alpha*V)/(1+alpha*h*V)
}
curve(TypeIIfuncresp(x,0.03,0.1),0,200,xlab="Victim abundance",ylab="Total prey eaten per predator",col="red",lwd=3)
TypeIIfuncresp <- function(V,alpha,h){
(alpha*V)/(1+alpha*h*V)
}
curve(TypeIIfuncresp(x,0.03,0.1),0,500,xlab="Victim abundance",ylab="Total prey eaten per predator",col="red",lwd=3)
TypeIIfuncresp <- function(V,alpha,h){
(alpha*V)/(1+alpha*h*V)
}
curve(TypeIIfuncresp(x,0.1,0.1),0,500,xlab="Victim abundance",ylab="Total prey eaten per predator",col="red",lwd=3)
TypeIfuncresp <- function(V,alpha){
alpha*V
}
curve(TypeIfuncresp(x,0.1),0,500,xlab="Victim abundance",ylab="Total prey eaten per predator",col="red",lwd=3)
TypeIIIfuncresp <- function(V,alpha,h,k){
(alpha*V^k)/(1+alpha*h*V^k)
}
curve(TypeIIIfuncresp(x,0.1,0.1,0.1),0,500,xlab="Victim abundance",ylab="Total prey eaten per predator",col="red",lwd=3)
TypeIIIfuncresp <- function(V,alpha,h,k){
(alpha*V^k)/(1+alpha*h*V^k)
}
curve(TypeIIIfuncresp(x,0.1,0.1,0.9),0,500,xlab="Victim abundance",ylab="Total prey eaten per predator",col="red",lwd=3)
TypeIIIfuncresp <- function(V,alpha,h,k){
(alpha*V^k)/(1+alpha*h*V^k)
}
curve(TypeIIIfuncresp(x,0.1,0.1,2),0,500,xlab="Victim abundance",ylab="Total prey eaten per predator",col="red",lwd=3)
TypeIIIfuncresp <- function(V,alpha,h,k){
(alpha*V^k)/(1+alpha*h*V^k)
}
curve(TypeIIIfuncresp(x,0.1,0.1,.01),0,500,xlab="Victim abundance",ylab="Total prey eaten per predator",col="red",lwd=3)
TypeIIIfuncresp <- function(V,alpha,h,k){
(alpha*V^k)/(1+alpha*h*V^k)
}
curve(TypeIIIfuncresp(x,0.1,0.1,.5),0,500,xlab="Victim abundance",ylab="Total prey eaten per predator",col="red",lwd=3)
TypeIIIfuncresp <- function(V,alpha,h,k){
(alpha*V^k)/(1+alpha*h*V^k)
}
curve(TypeIIIfuncresp(x,0.1,0.1,.9),0,500,xlab="Victim abundance",ylab="Total prey eaten per predator",col="red",lwd=3)
TypeIIIfuncresp <- function(V,alpha,h,k){
(alpha*V^k)/(1+alpha*h*V^k)
}
curve(TypeIIIfuncresp(x,0.1,0.1,.9999),0,500,xlab="Victim abundance",ylab="Total prey eaten per predator",col="red",lwd=3)
TypeIIIfuncresp <- function(V,alpha,h,k){
(alpha*V^k)/(1+alpha*h*V^k)
}
curve(TypeIIIfuncresp(x,0.1,0.1,1.01),0,500,xlab="Victim abundance",ylab="Total prey eaten per predator",col="red",lwd=3)
TypeIIIfuncresp <- function(V,alpha,h,k){
(alpha*V^k)/(1+alpha*h*V^k)
}
curve(TypeIIIfuncresp(x,0.1,0.1,1.05),0,500,xlab="Victim abundance",ylab="Total prey eaten per predator",col="red",lwd=3)
TypeIIIfuncresp <- function(V,alpha,h,k){
(alpha*V^k)/(1+alpha*h*V^k)
}
curve(TypeIIIfuncresp(x,0.1,0.1,1.1),0,500,xlab="Victim abundance",ylab="Total prey eaten per predator",col="red",lwd=3)
TypeIIIfuncresp <- function(V,alpha,h,k){
(alpha*V^k)/(1+alpha*h*V^k)
}
curve(TypeIIIfuncresp(x,0.1,0.1,-0.5),0,500,xlab="Victim abundance",ylab="Total prey eaten per predator",col="red",lwd=3)
TypeIIIfuncresp <- function(V,alpha,h,k){
(alpha*V^k)/(1+alpha*h*V^k)
}
curve(TypeIIIfuncresp(x,0.1,0.1,1.6),0,500,xlab="Victim abundance",ylab="Total prey eaten per predator",col="red",lwd=3)
TypeIIIfuncresp <- function(V,alpha,h,k){
(alpha*V^k)/(1+alpha*h*V^k)
}
curve(TypeIIIfuncresp(x,0.01,0.1,1.6),0,500,xlab="Victim abundance",ylab="Total prey eaten per predator",col="red",lwd=3)
TypeIIIfuncresp <- function(V,alpha,h,k){
(alpha*V^k)/(1+alpha*h*V^k)
}
curve(TypeIIIfuncresp(x,0.005,0.1,1.9),0,500,xlab="Victim abundance",ylab="Total prey eaten per predator",col="red",lwd=3)
TypeIIIfuncresp <- function(V,alpha,h,k){
(alpha*V^k)/(1+alpha*h*V^k)
}
curve(TypeIIIfuncresp(x,0.005,0.1,1.6),0,500,xlab="Victim abundance",ylab="Total prey eaten per predator",col="red",lwd=3)
TypeIIIfuncresp <- function(V,alpha,h,k){
(alpha*V^k)/(1+alpha*h*V^k)
}
curve(TypeIIIfuncresp(x,0.005,0.1,1.4),0,500,xlab="Victim abundance",ylab="Total prey eaten per predator",col="red",lwd=3)
TypeIIIfuncresp <- function(V,alpha,h,k){
(alpha*V^k)/(1+alpha*h*V^k)
}
curve(TypeIIIfuncresp(x,0.005,0.1,1.6),0,500,xlab="Victim abundance",ylab="Total prey eaten per predator",col="red",lwd=3)
TypeIIIfuncresp <- function(V,alpha,h,k){
(alpha*V^k)/(1+alpha*h*V^k)
}
curve(TypeIIIfuncresp(x,0.0005,0.1,1.6),0,500,xlab="Victim abundance",ylab="Total prey eaten per predator",col="red",lwd=3)
TypeIIIfuncresp <- function(V,alpha,h,k){
(alpha*V^k)/(1+alpha*h*V^k)
}
curve(TypeIIIfuncresp(x,0.0005,0.1,1.6),0,1000,xlab="Victim abundance",ylab="Total prey eaten per predator",col="red",lwd=3)
TypeIIIfuncresp <- function(V,alpha,h,k){
(alpha*V^k)/(1+alpha*h*V^k)
}
curve(TypeIIIfuncresp(x,0.0005,0.1,1.6),0,1000,xlab="Victim abundance",ylab="Total prey eaten per predator",col="red",lwd=3)
?text
par()
?legend
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
Elephant_age <- seq(0,60,by=2)
Birth_rate <- c(rep(0,times=7),seq(0,0.3,length=4),rep(0.3,times=15),seq(0.3,0,length=5))
names(Birth_rate) <- Elephant_age
barplot(Birth_rate,xlab="Age",ylab="b, per-capita birth rate",col="blue")
Tortoise_age <- seq(0,120,by=5)
Death_rate <- c(seq(0.7,0.05,length=5),seq(0.05,0.05,length=16),seq(0.05,0.5,length=4))
names(Death_rate) <- Tortoise_age
barplot(Death_rate,xlab="Age",ylab="d, per-capita death rate",col="blue")
ln(1.1)
log(1.1)
exp(0.09)
2.5*0.75
.5/2.5
2.5*.8
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
## Params
Alpha <- 0.001
Beta <- 0.005
r <- 0.2
q <- 0.1
c <- 0.008
InitPrey <- 100
InitPred <- 75
Nyears <- 100
step <- 0.1
System <- data.frame(prey = rep(InitPrey,(Nyears+1)*10),pred = InitPred)
doYear <- function(prevyear){
n1 <- prevyear[1] + r*prevyear[1]*step - Alpha*prevyear[1]*prevyear[2]*step - c*prevyear[1]^2*step
n2 <- prevyear[2] + Beta*prevyear[1]*prevyear[2]*step - q*prevyear[2]*step
return(c(n1,n2))
}
## Do simulation
for(i in 1:(Nyears*10+1)){
System[1+i,] <- doYear(System[i,])
}
##### LOTKA VOLTERRA PREDATION EXAMPLE
## Params
InitN1 <- 100
InitN2 <- 200
System1 <- data.frame(n1 = rep(InitN1,(Nyears*10+1)),n2 = InitN2)
## Do simulation
for(i in 1:(Nyears*10+1)){
System1[1+i,] <- doYear(System1[i,])
}
InitN1 <- 100
InitN2 <- 100
System2 <- data.frame(n1 = rep(InitN1,(Nyears*10+1)),n2 = InitN2)
## Do simulation
for(i in 1:(Nyears*10+1)){
System2[1+i,] <- doYear(System2[i,])
}
InitN1 <- 50
InitN2 <- 20
System3 <- data.frame(n1 = rep(InitN1,(Nyears*10+1)),n2 = InitN2)
## Do simulation
for(i in 1:(Nyears*10+1)){
System3[1+i,] <- doYear(System3[i,])
}
plot(1,1,pch="",xlim=xlim,ylim=ylim,xlab="Prey",ylab="Predators")
phasearrows.draw(new)
abline((r/Alpha),-(c/Alpha),col="red",lwd=3)   # prey
abline(v=q/Beta,col="blue",lwd=3)   # pred
points(jitter(System[,1],500),jitter(System[,2],500),col="brown",pch=20,cex=0.3)
points(jitter(System1[,1],500),jitter(System1[,2],500),col="green",pch=20,cex=0.3)
points(jitter(System2[,1],500),jitter(System2[,2],500),col="red",pch=20,cex=0.3)
points(jitter(System3[,1],500),jitter(System3[,2],500),col="blue",pch=20,cex=0.3)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
Density <- seq (0,500,1) # crea una secuencia de números del 0 al 500, que representa un rango de densidades de población
## CONSTANTES
b_max <- 0.8  # maximo de reprodución (a densidad baja)
d_min <- 0.3  # minimo de mortalidad
a <- 0.001    # D-D terminos
c <- 0.0005
b <- b_max - a*Density
d <- d_min + c*Density
plot(Density,b,type="l",col="green",lwd=2,ylim=c(0,1),main="Density-Dependence!",ylab="b or d")
points(Density,d,type="l",col="red",lwd=2)
axis(4,at=seq(0,1,0.2))
#mtext("d",4)
legend("bottomleft",col=c("green","red"),lty=c(1,1),legend=c("per-capita birth rate","per-capita mortality"),bty="n")
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
Elephant_age <- seq(0,60, by=2)
Birth_rate <- c(rep(0,times=7),seq(0,0.3,length=4),rep(0.3,times=15),seq(0.3,0,length=5))
names(Birth_rate) <- Elephant_age
barplot(Birth_rate,xlab="Age",ylab="b, per-capita birth rate",col="blue",ylim=c(0,0.5))
Tortoise_age <- seq(0,120,by=5)
Death_rate <- c(seq(0.7,0.05,length=5),seq(0.02,0.02,length=16),seq(0.02,0.5,length=4))
names(Death_rate) <- Tortoise_age
barplot(Death_rate,xlab="Age",ylab="d, per-capita death rate",col="blue")
knitr::kable(lifetable,caption="",col.names = c("x","S(x)","b(x)","l(x)","g(x)"))
lifetable <- read.csv("life_table.csv")
knitr::kable(lifetable,caption="",col.names = c("x","S(x)","b(x)","l(x)","g(x)"))
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
#########
# Project the population at time 1
Year1 <- teasel_matrix %*% Initial_teasel   # note: the '%*%' denotes 'matrix multiplication' in R. We'll go through this more later.
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
############################################################
####                                                    ####
####  BIOL4558, Topico 7                               ####
####                                                    ####
####  Kevin Shoemaker                                   ####
####  University of Nevada, Reno                    ####
####        &                           ####
####  Raymond L. Tremblay       ####
####  Universidad de Puerto Rico                   ####
####                                                    ####
############################################################
############################################################
####  Matrix population models                          ####
############################################################
#########
# Teasel example from Gotelli: summarizing a complex life history!
teasel <- read.csv("teaselmatrix1.csv", header=T)      # read in the teasel transition matrix from Gotelli
teasel <- teasel[,-1]                                  # remove the row names
teasel_matrix <- as.matrix(teasel)                     # convert to a matrix (from a data frame)
colnames(teasel_matrix) <- names(teasel)               # assign row and column names
rownames(teasel_matrix) <- names(teasel)
teasel_matrix                                          # print the matrix
#############
# Summarize initial age-structured abundance as a matrix with one column
Initial_teasel <- matrix(c(1000,1500,200,300,600,25),ncol=1)         # initial population size (population vector; matrix with 1 column!)
rownames(Initial_teasel) <- rownames(teasel_matrix)                  # add row and column names
colnames(Initial_teasel) <- "Abundance"
Initial_teasel
#########
# Project the population at time 1
Year1 <- teasel_matrix %*% Initial_teasel   # note: the '%*%' denotes 'matrix multiplication' in R. We'll go through this more later.
Year1
#########
# Project the population at time 2
thisYear <- Year1
nextYear <- teasel_matrix %*% thisYear
nextYear  # now we get the (age structured) population size at time 2!
########
# Use a for loop to project the population dynamics for the next 10 years!
nYears <- 10
tenYears <- matrix(0,nrow=6,ncol=nYears+1)          # initialize storate array for recording age structured abundances for the next 10 years.
rownames(tenYears) <- rownames(Initial_teasel)      # assign row and column names
colnames(tenYears) <- seq(0,10)
tenYears[,1] <- Initial_teasel                      # initialize the simulated abundances
##########
# run the for loop!
for(t in 2:(nYears+1)){    # here we use 't' as our looping variable, but we could choose any name we want
tenYears[,t] <-  teasel_matrix %*% tenYears[,t-1]     # perform matrix multiplication for each year of the simulation!
}
tenYears
#########
# Plot the projected population trajectory over the next 10 years
plot(1,1,pch="",ylim=c(0,60000000),xlim=c(0,11),xlab="Years",ylab="Abundance",xaxt="n")    # make empty plot
cols <- rainbow(6)        # set colors for each stage
for(s in 1:6){
points(tenYears[s,],col=cols[s],type="l",lwd=2)       # plot out each stage
}
axis(1,at=seq(1,11),labels = seq(0,10))      # add x axis labels
legend("topleft",col=cols,lwd=rep(2,6),legend=rownames(tenYears))      # add legend
###########
# Use the transition matrix to compute Lambda, or the finite rate of population growth!
Lambda <- as.numeric(round(eigen(teasel_matrix)$values[1],2))
Lambda
library(popbio)      # or... it's easier to use the 'popbio' library in R!
lambda(teasel_matrix)
##########
# Compute stable age distribution from the transition matrix!
SAD <- abs(as.numeric(round(eigen(teasel_matrix)$vectors[,1],3)))
SAD/sum(SAD)      # stable age distribution as a percentage of the total population
library(popbio)    # ... and it's even easier if we use the 'popbio' package...
stable.stage(teasel_matrix)
###################
# In class demo: convert an insightmaker model to a matrix projection model
###########
# First, we specify a blank transition matrix
TMat <- matrix(0,nrow=3,ncol=3)                    # create a blank matrix with 3 rows and 3 columns
stagenames <- c("Juveniles","Subadults","Adults")  # name the rows and columns
rownames(TMat) <- stagenames
colnames(TMat) <- stagenames
TMat                                               # now we have an all-zero transition matrix.
#####
# fill in the top left element of the matrix
TMat[1,1] <- 0
TMat
#####
# update the second row, first column
TMat[2,1] <- 0.3
TMat
#####
# and keep filling it in...
TMat[,1] <- c(0,0.3,0)          # fill in the entire first column of the transition matrix
TMat[,2] <- c(0,0.4,0.1)        # fill in the entire second column of the transition matrix
TMat[,3] <- c(4,0,0.85)         # fill in the entire third column of the transition matrix
TMat
######
# specify initial abundance vector
InitAbund <- c(40,0,0)
names(InitAbund) <- colnames(TMat)
InitAbund
#######
# Run the model for 40 years (using for loop)
nYears <- 40
allYears <- matrix(0,nrow=nrow(TMat),ncol=nYears+1)
rownames(allYears) <- rownames(TMat)
colnames(allYears) <- seq(0,nYears)
allYears[,1] <- InitAbund
for(t in 2:(nYears+1)){
allYears[,t] <-  TMat %*% allYears[,t-1]
}
allYears
#####
# and plot out the results!
plot(1,1,pch="",ylim=c(0,50),xlim=c(0,nYears+1),xlab="Years",ylab="Abundance",xaxt="n")
cols <- rainbow(3)
for(s in 1:3){
points(allYears[s,],col=cols[s],type="l",lwd=2)
}
axis(1,at=seq(1,nYears+1),labels = seq(0,nYears))
legend("topleft",col=cols,lwd=rep(2,3),legend=rownames(allYears))
########
# Use a for loop to project the population dynamics for the next 10 years!
nYears <- 10
tenYears <- matrix(0,nrow=6,ncol=nYears+1)          # initialize storate array for recording age structured abundances for the next 10 years.
rownames(tenYears) <- rownames(Initial_teasel)      # assign row and column names
colnames(tenYears) <- seq(0,10)
tenYears[,1] <- Initial_teasel                      # initialize the simulated abundances
##########
# run the for loop!
for(t in 2:(nYears+1)){    # here we use 't' as our looping variable, but we could choose any name we want
tenYears[,t] <-  teasel_matrix %*% tenYears[,t-1]     # perform matrix multiplication for each year of the simulation!
}
tenYears
#########
# Plot the projected population trajectory over the next 10 years
plot(1,1,pch="",ylim=c(0,60000000),xlim=c(0,11),xlab="Years",ylab="Abundance",xaxt="n")    # make empty plot
cols <- rainbow(6)        # set colors for each stage
for(s in 1:6){
points(tenYears[s,],col=cols[s],type="l",lwd=2)       # plot out each stage
}
axis(1,at=seq(1,11),labels = seq(0,10))      # add x axis labels
legend("topleft",col=cols,lwd=rep(2,6),legend=rownames(tenYears))      # add legend
