install.packages(c("devtools", "expm", "MCMCpack", "markovchain"))
install.packages(c("devtools", "expm", "MCMCpack", "markovchain"))
# Install stable version from GitHub (recommended):
# NOTE don't forget to change the version number!
library(popdemo)
# Install dependencies from CRAN:
install.packages(c("devtools", "expm", "MCMCpack", "markovchain"))
# Install stable version from GitHub (recommended):
# NOTE don't forget to change the version number!
library(popdemo)
# Install development version 'popdemoDev' (not recommended):
devtools::install_github("iainmstott/popdemo/Dev/popdemoDev", ref = "development")
install.packages(c("devtools", "expm", "MCMCpack", "markovchain"))
data(Tort)
data(Tort); Tort
Tortvec1 <- runif(8)
Tortvec1 <- Tortvec1/sum(Tortvec1) #scales the vector to sum to 1
( Tortp1.1 <- project(Tort, Tortvec1, time = 100) )
vec(Tortp1.1)[1:11, ]
vec(Tortp1.1)[ , 2]
vec(Tortp1.1)[10 , 2]
vec(Tortp1.1)[10, 2]
vec(Tortp1.1)[, 2]
eigs(Tort, "all")
eigs(Tort, "all")
project(Tort, Tortvec1, time = 100)
plot(Tort)
plot(Tortp1.1)
Tortvec1 <- runif(8)
Tortvec1 <- Tortvec1/sum(Tortvec1) #scales the vector to sum to 1
plot(Tortp1.1, log = "y")
Tortw <- eigs(Tort, "ss")
Tortpw <- project(Tort, Tortw, time = 100)
lines(0:100, Tortpw, lty = 2)
Tortw <- eigs(Tort, "ss")
Tortpw <- project(Tort, Tortw, time = 100)
lines(0:100, Tortpw, lty = 2)
lines(0:100, Tortpw, lty = 2)
Tortw <- eigs(Tort, "ss")
Tortpw <- project(Tort, Tortw, time = 100)
Tortpw
Tortw
lines(0:100, Tortpw, lty = 2)
Tortp1.1s <- project(Tort, Tortvec1, time = 100,
standard.A = TRUE, standard.vec = TRUE)
Tortpws <- project(Tort, Tortw, time = 100,
standard.A = TRUE, standard.vec = TRUE)
plot(Tortp1.1s, log = "y")
lines(Tortpws, lty = 2)
Tortw <- eigs(Tort, "ss")
Tortpw <- project(Tort, Tortw, time = 100)
lines(Tortpw, lty = 2)
Tortw <- eigs(Tort, "ss")
Tortpw <- project(Tort, Tortw, time = 100)
plot(Tortpw, log = "y")
lines(Tortpw, lty = 2)
Tortw <- eigs(Tort, "ss")
Tortpw <- project(Tort, Tortw, time = 100)
plot(Tortpw, log = "y")
lines(Tortw, lty = 2)
Tortp1.1s <- project(Tort, Tortvec1, time = 100,
standard.A = TRUE, standard.vec = TRUE)
Tortpws <- project(Tort, Tortw, time = 100,
standard.A = TRUE, standard.vec = TRUE)
plot(Tortp1.1s, log = "y")
lines(Tortpws, lty = 2)
( r1 <- reac(Tort, Tortvec1) )
##   [1] 1.136
( i1 <- inertia(Tort, Tortvec1) )
##   [1] 1.777
points(c(1, 100), c(r1, i1), pch = 3, col = "red")
( r1 <- reac(Tort, Tortvec1) )
##   [1] 1.136
( i1 <- inertia(Tort, Tortvec1) )
##   [1] 1.777
Tortp1.1s <- project(Tort, Tortvec1, time = 100,
standard.A = TRUE, standard.vec = TRUE)
Tortpws <- project(Tort, Tortw, time = 100,
standard.A = TRUE, standard.vec = TRUE)
plot(Tortp1.1s, log = "y")
lines(Tortpws, lty = 2)
points(c(1, 100), c(r1, i1), pch = 3, col = "red")
TortAMP <- c(1, 1, 2, 3, 5, 8, 13, 21) #a population that amplifies
TortATT <- c(21, 13, 8, 5, 3, 2, 1, 1) #a population that attenuates
TortBTH <- c(0, 0, 0, 1, 0, 0, 0, 0) #a population that does both
Tortvec3 <- cbind(AMP = TortAMP,
ATT = TortATT,
BTH = TortBTH)
Tortp3.1 <- project(Tort, Tortvec3, time = 100,
standard.A = TRUE, standard.vec = TRUE)
plot(Tortp3.1, log = "y"); lines(Tortpws, lty = 2)
( r3 <- apply(Tortvec3, 2, reac, A = Tort) )
##      AMP    ATT    BTH
##   2.6319 0.9153 0.8757
( r3t <- rep(1, 3) )
##   [1] 1 1 1
( i3 <- apply(Tortvec3, 2, inertia, A = Tort) )
##      AMP    ATT    BTH
##   4.1442 0.9123 1.8019
( i3t <- rep(100, 3) )
##   [1] 100 100 100
( max3 <- apply(Tortvec3[,c(1,3)], 2, maxamp, A = Tort) )
##     AMP   BTH
##   5.111 1.962
( max3t <- apply(Tortvec3[,c(1,3)], 2, function(x){
maxamp(vector = x, A = Tort, return.t = TRUE)$t}) )
##   AMP BTH
##     6  13
( min3 <- apply(Tortvec3[,c(2,3)], 2, maxatt, A = Tort) )
##      ATT    BTH
##   0.8377 0.7261
( min3t <- apply(Tortvec3[,c(2,3)], 2, function(x){
maxatt(vector = x, A = Tort, return.t = TRUE )$t}) )
##   ATT BTH
##     4   3
points(c(r3t, i3t, max3t, min3t),
c(r3, i3, max3, min3),
pch = 3, col = "red")
plot(Tortp1.1s, log = "y", bounds = TRUE)
plot(project(Tort, standard.A = TRUE), log = "y")
Tortpd <- project(Tort, "diri", time = 31,
standard.A = TRUE)
##   Warning in .recacheSubclasses(def@className, def, env): undefined subclass
##   "numericVector" of class "Mnumeric"; definition not updated
plot(Tortpd, plottype = "shady", bounds = T, log = "y")
TeaTasting <-
matrix(c(3, 1, 1, 3),
nrow = 2,
dimnames = list(Guess = c("Milk", "Tea"),
Truth = c("Milk", "Tea")))
fisher.test(TeaTasting, alternative = "greater")
## => p = 0.2429, association could not be established
## Fisher (1962, 1970), Criminal convictions of like-sex twins
Convictions <- matrix(c(2, 10, 15, 3), nrow = 2,
dimnames =
list(c("Dizygotic", "Monozygotic"),
c("Convicted", "Not convicted")))
Convictions
fisher.test(Convictions, alternative = "less")
fisher.test(Convictions, conf.int = FALSE)
fisher.test(Convictions, conf.level = 0.95)$conf.int
fisher.test(Convictions, conf.level = 0.99)$conf.int
fisher.test(Convictions, alternative = "less")
data(Tort)
Tort
knitr::opts_chunk$set(echo = TRUE)
# Install dependencies from CRAN:
#install.packages(c("devtools", "expm", "MCMCpack", "markovchain"))
# Install stable version from GitHub (recommended):
# NOTE don't forget to change the version number!
library(popdemo)
# Install development version 'popdemoDev' (not recommended):
#devtools::install_github("iainmstott/popdemo/Dev/popdemoDev", ref = "development")
#library(popdemoDev)
data(Tort)
Tort
Tortvec1 <- runif(8)
Tortvec1 <- Tortvec1/sum(Tortvec1) #scales the vector to sum to 1
( Tortp1.1 <- project(Tort, Tortvec1, time = 100) )
plot(Tortp1.1, log = "y")
vec(Tortp1.1)[1:11, ]
vec(Tortp1.1)[, 2]
eigs(Tort, "all")
Tortp1.1s <- project(Tort, Tortvec1, time = 100,
standard.A = TRUE, standard.vec = TRUE)
Tortpws <- project(Tort, Tortw, time = 100,
standard.A = TRUE, standard.vec = TRUE)
plot(Tortp1.1s, log = "y")
lines(Tortpws, lty = 2)
( r1 <- reac(Tort, Tortvec1) )
##   [1] 1.136
( i1 <- inertia(Tort, Tortvec1) )
##   [1] 1.777
## Copiar el chunk ariba
Tortp1.1s <- project(Tort, Tortvec1, time = 100,
standard.A = TRUE, standard.vec = TRUE)
Tortpws <- project(Tort, Tortw, time = 100,
standard.A = TRUE, standard.vec = TRUE)
plot(Tortp1.1s, log = "y")
lines(Tortpws, lty = 2)
points(c(1, 100), c(r1, i1), pch = 3, col = "red")
TortAMP <- c(1, 1, 2, 3, 5, 8, 13, 21) #a population that amplifies
TortATT <- c(21, 13, 8, 5, 3, 2, 1, 1) #a population that attenuates
TortBTH <- c(0, 0, 0, 1, 0, 0, 0, 0) #a population that does both
Tortvec3 <- cbind(AMP = TortAMP,
ATT = TortATT,
BTH = TortBTH)
Tortp3.1 <- project(Tort, Tortvec3, time = 100,
standard.A = TRUE, standard.vec = TRUE)
plot(Tortp3.1, log = "y"); lines(Tortpws, lty = 2)
( r3 <- apply(Tortvec3, 2, reac, A = Tort) )
##      AMP    ATT    BTH
##   2.6319 0.9153 0.8757
( r3t <- rep(1, 3) )
##   [1] 1 1 1
( i3 <- apply(Tortvec3, 2, inertia, A = Tort) )
##      AMP    ATT    BTH
##   4.1442 0.9123 1.8019
( i3t <- rep(100, 3) )
##   [1] 100 100 100
( max3 <- apply(Tortvec3[,c(1,3)], 2, maxamp, A = Tort) )
##     AMP   BTH
##   5.111 1.962
( max3t <- apply(Tortvec3[,c(1,3)], 2, function(x){
maxamp(vector = x, A = Tort, return.t = TRUE)$t}) )
##   AMP BTH
##     6  13
( min3 <- apply(Tortvec3[,c(2,3)], 2, maxatt, A = Tort) )
##      ATT    BTH
##   0.8377 0.7261
( min3t <- apply(Tortvec3[,c(2,3)], 2, function(x){
maxatt(vector = x, A = Tort, return.t = TRUE )$t}) )
##   ATT BTH
##     4   3
points(c(r3t, i3t, max3t, min3t),
c(r3, i3, max3, min3),
pch = 3, col = "red")
plot(Tortp1.1s, log = "y", bounds = TRUE)
plot(project(Tort, standard.A = TRUE), log = "y")
Tortpd <- project(Tort, "diri", time = 31,
standard.A = TRUE)
##   Warning in .recacheSubclasses(def@className, def, env): undefined subclass
##   "numericVector" of class "Mnumeric"; definition not updated
plot(Tortpd, plottype = "shady", bounds = T, log = "y")
pr1 <- project(TF, vector=n0, time=24)
#Plot the projection. This uses an S3 plotting
#method for projections. For info, see '?plot.projection'.
plot(pr1)
TF
pr1 <- project(TF, vector=n0, time=24)
#Plot the projection. This uses an S3 plotting
#method for projections. For info, see '?plot.projection'.
plot(pr1)
TF
eigs <- eigen(TF)
eigs # los diferentes eigenvalue de la matrix. El que responde al crecimiento intrinsico de la población es la parte mayor real.
truelambda(TF) # Con el paquete popdemo
lambda(TF) # con el paquete popbio
popbio::lambda(TF) # con el paquete popbio
eigs <- eigen(TF)
eigs # los diferentes eigenvalue de la matrix. El que responde al crecimiento intrinsico de la población es la parte mayor real.
popbio::lambda(TF) # con el paquete popbio
w <- stable.stage(TF)
w
w <- stable.stage(TF)
library(popbio)
w <- stable.stage(TF)
w
matACc
stable.stage(matACc) # en el paquete popdemo
eigen(TF)
eigen(TF)
# Calcular a mano el damping.ratio
1.0296/abs(0.7709)
dr(TF, return.time=TRUE, x=10)
eigen(matACc)
0.95158/abs(0.711699)
dr(matACc)
dr(matACc, return.time=TRUE, x=10) # damping ratio
# convt, en popdemo
n=c(1000,0,0,0, 0)
convt(matACc, accuracy=1e-3, vector=n) # Convergence time to Stable Stage Distribution from an invasive species starting with smallest size
n1=c(238,648,103,7, 3)
convt(matACc, accuracy=1e-3, vector=n1) # Convergence time to Stable Stage Distribution when close to Stable Stage
# convt, en popdemo
n=c(1000,0,0,0, 0)
convt(matACc, accuracy=1e-3, vector=n) # Convergence time to Stable Stage Distribution from an invasive species starting with smallest size
n1=c(238,648,103,7, 3)
convt(matACc, accuracy=1e-3, vector=n1) # Convergence time to Stable Stage Distribution when close to Stable Stage
n2=c(0,0,0,0,1000)
convt(matACc, accuracy=1e-3, vector=n2) # Convergence time to Stable Stage Distribution when starting with an invasive species of adults
library(popdemoDev)
detach("package:popdemoDev", unload = TRUE)
library(popdemoDev)
detach("package:popdemoDev", unload = TRUE)
# Install dependencies from CRAN:
install.packages(c("devtools", "expm", "MCMCpack", "markovchain"))
# Install stable version from GitHub (recommended):
# NOTE don't forget to change the version number!
library(popdemo)
# Install development version 'popdemoDev' (not recommended):
devtools::install_github("iainmstott/popdemo/Dev/popdemoDev", ref = "development")
install.packages(c("devtools", "expm", "MCMCpack", "markovchain"))
#library(popdemoDev)
data(Tort)
Tort
Tortvec1 <- runif(8)
Tortvec1 <- Tortvec1/sum(Tortvec1) #scales the vector to sum to 1
( Tortp1.1 <- project(Tort, Tortvec1, time = 100) )
plot(Tortp1.1, log = "y")
plot(Tortp1.1)
plot(Tortp1.1, log = "y")
( Tortp1.1 <- project(Tort, Tortvec1, time = 20) )
plot(Tortp1.1, log = "y")
Tortvec1 <- runif(8) # el 8 se refiere que hay 8 etapas
Tortvec1 <- Tortvec1/sum(Tortvec1) #scales the vector to sum to 1
( Tortp1.1 <- project(Tort, Tortvec1, time = 20) )
plot(Tortp1.1, log = "y")
Tortvec1 <- runif(8) # el 8 se refiere que hay 8 etapas
Tortvec1 <- Tortvec1/sum(Tortvec1) #scales the vector to sum to 1
( Tortp1.1 <- project(Tort, Tortvec1, time = 200) )
plot(Tortp1.1, log = "y")
Tortvec1 <- runif(8) # el 8 se refiere que hay 8 etapas
Tortvec1 <- Tortvec1/sum(Tortvec1) #scales the vector to sum to 1
( Tortp1.1 <- project(Tort, Tortvec1, time = 100) )
plot(Tortp1.1, log = "y")
vec(Tortp1.1)[1:11,1 ]
vec(Tortp1.1)[1:11,1:5 ]
vec(Tortp1.1)[1:11, ]
Tortvec1 <- runif(8) # el 8 se refiere que hay 8 etapas
Tortvec1 <- Tortvec1/sum(Tortvec1) #scales the vector to sum to 1
( Tortp1.1 <- project(Tort, Tortvec1, time = 11) )
plot(Tortp1.1, log = "y")
vec(Tortp1.1)[1:11, ]
vec(Tortp1.1)[1:11, ]
vec(Tortp1.1)[1:11, ]
vec(Tortp1.1)[1:11, ]
Tortvec1 <- runif(8) # el 8 se refiere que hay 8 etapas
Tortvec1 <- Tortvec1/sum(Tortvec1) #scales the vector to sum to 1
( Tortp1.1 <- project(Tort, Tortvec1, time = 11) )
plot(Tortp1.1, log = "y")
vec(Tortp1.1)[1:11, ]
vec(Tortp1.1)[1:11, ]
Tortvec1 <- runif(8) # el 8 se refiere que hay 8 etapas
Tortvec1 <- Tortvec1/sum(Tortvec1) #scales the vector to sum to 1
( Tortp1.1 <- project(Tort, Tortvec1, time = 11) )
plot(Tortp1.1, log = "y")
vec(Tortp1.1)[1:11, ]
Tortvec1 <- runif(8) # el 8 se refiere que hay 8 etapas
Tortvec1 <- Tortvec1/sum(Tortvec1) #scales the vector to sum to 1
( Tortp1.1 <- project(Tort, Tortvec1, time = 100) )
plot(Tortp1.1, log = "y")
vec(Tortp1.1)[1:11, ]
Tortvec1 <- runif(8) # el 8 se refiere que hay 8 etapas
Tortvec1 <- Tortvec1/sum(Tortvec1) #scales the vector to sum to 1
( Tortp1.1 <- project(Tort, Tortvec1, time = 100) )
plot(Tortp1.1, log = "y")
vec(Tortp1.1)[1:11, ]
vec(Tortp1.1)[1:11, ]
vec(Tortp1.1)[, 2]
vec(Tortp1.1)[, 2]
vec(Tortp1.1)[, 2]
vec(Tortp1.1)[1:11, ]
vec(Tortp1.1)[1:11, ]
vec(Tortp1.1)[1:11, ]
vec(Tortp1.1)[1:11, ]
Tortvec1 <- runif(8) # el 8 se refiere que hay 8 etapas
Tortvec1 <- Tortvec1/sum(Tortvec1) #scales the vector to sum to 1
( Tortp1.1 <- project(Tort, Tortvec1, time = 11) )
plot(Tortp1.1, log = "y")
vec(Tortp1.1)[1:11, ]
vec(Tortp1.1)[1:11, ]
set.seed(1234)
Tortvec1 <- runif(8) # el 8 se refiere que hay 8 etapas
Tortvec1 <- Tortvec1/sum(Tortvec1) #scales the vector to sum to 1
( Tortp1.1 <- project(Tort, Tortvec1, time = 11) )
plot(Tortp1.1, log = "y")
vec(Tortp1.1)[1:11, ]
#set.seed(1234)
Tortvec1 <- runif(8) # el 8 se refiere que hay 8 etapas
Tortvec1 <- Tortvec1/sum(Tortvec1) #scales the vector to sum to 1
( Tortp1.1 <- project(Tort, Tortvec1, time = 11) )
plot(Tortp1.1, log = "y")
vec(Tortp1.1)[1:11, ]
set.seed(1234)
Tortvec1 <- runif(8) # el 8 se refiere que hay 8 etapas
Tortvec1 <- Tortvec1/sum(Tortvec1) #scales the vector to sum to 1
( Tortp1.1 <- project(Tort, Tortvec1, time = 11) )
plot(Tortp1.1, log = "y")
vec(Tortp1.1)[1:11, ]
Tort
vec(Tortp1.1)[, 2]
Tort
vec(Tortp1.1)[1:11, ]
Tort
stable.stage(Tort)
vec(Tortp1.1)[1:11, ]
vec(Tortp1.1)[1:100, ]
#nT=c(10000, 500, 300, .....)
stable.stage(Tort)
vec(Tortp1.1)[1:100, ]
vec(Tortp1.1)[1:20, ]
set.seed(1234)
Tortvec1 <- runif(8) # el 8 se refiere que hay 8 etapas
Tortvec1 <- Tortvec1/sum(Tortvec1) #scales the vector to sum to 1
( Tortp1.1 <- project(Tort, Tortvec1, time = 11) )
plot(Tortp1.1, log = "y")
#nT=c(10000, 500, 300, .....)
stable.stage(Tort)
vec(Tortp1.1)[1:20, ]
vec(Tortp1.1)[1:11, ]
vec(Tortp1.1)[1:15, ]
vec(Tortp1.1)[1:11, ]
vec(Tortp1.1)[, 8]
vec(Tortp1.1)[, 2]
eigs(Tort, "all")
Tort
eigs(Tort, "all")
#To show (e.g.) means, you need geom_col()
df <- data.frame(trt = c("a", "b", "c", "d", "e"), outcome = c(5, 4, 6, 2, 1))
p1=ggplot(df, aes(trt, outcome)) +
geom_col(aes(fill=trt))+
guides(fill=FALSE)+theme_void() + theme_transparent()
library(Rage)
matU1=matrix(c(
0.43, 	0,	  0,    0.00,
0.38,	0.84, 	0,	  0,
0, 	    0,	  0.51,	0.15,
0,      0.14, 0.43, 0.44
), byrow=4, ncol=4)
matU1
matF1=matrix(c(
0, 	  0,	  0,    0.14,
0,	  0, 	  0,	  0,
0, 	  0,	  0,	  0,
0,    0,    0,    0
), byrow=4, ncol=4)
matF1
TF1=matU1+matF1
TF1
lambda(TF1)
library(Rage)
matU1=matrix(c(
0.43, 	0,	  0,    0.00,
0.38,	0.84, 	0,	  0,
0, 	    0,	  0.51,	0.15,
0,      0.14, 0.43, 0.44
), byrow=4, ncol=4)
matU1
matF1=matrix(c(
0, 	  0,	  0,    0.14,
0,	  0, 	  0,	  0,
0, 	  0,	  0,	  0,
0,    0,    0,    0
), byrow=4, ncol=4)
matF1
TF1=matU1+matF1
TF1
lambda(TF1)
knitr::opts_chunk$set(echo = TRUE)
library(popdemo)
library(popbio)
#remotes::install_github("jonesor/Rage")
library(Rage)
matU=matrix(c(
0.43, 	0,	    0.00,   0.00,
0.38,	  0.84,   0.00,	  0.00,
0, 	    0.00,	  0.51,	  0.15,
0,      0.14,   0.43,   0.84),
byrow=4, ncol=4)
matU
matF=matrix(c(
0, 	  0,	  0,    0.14,
0,	  0, 	  0,	  0,
0, 	  0,	  0,	  0,
0,    0,    0,    0
), byrow=4, ncol=4)
matF
TF=matU+matF
TF
colnames(TF) <- c("plantulas", "juveniles", "A no reprod", "A reprod")
rownames(TF) <- colnames(TF)
TF
orchid_names= c("1_plantulas", "2_juveniles", "3_adulto no reproductivos", "4_adultos reproductivos")
orchid_names_2= c("1", "2", "3", "4")
#stages <- c(TF_TF)
plot_life_cycle(TF)
#plot_life_cycle(TF, stages = orchid_names_2)
TF
library(popbio)
lambda(TF) # crecimiento de 3%
library(Rage)
matU1=matrix(c(
0.43, 	0,	  0,    0.00,
0.38,	0.84, 	0,	  0,
0, 	    0,	  0.51,	0.15,
0,      0.14, 0.43, 0.44
), byrow=4, ncol=4)
matU1
matF1=matrix(c(
0, 	  0,	  0,    0.14,
0,	  0, 	  0,	  0,
0, 	  0,	  0,	  0,
0,    0,    0,    0
), byrow=4, ncol=4)
matF1
TF1=matU1+matF1
TF1
lambda(TF1)
library(Rage)
matU1=matrix(c(
0.43, 	0,	  0,    0.00,
0.38,	0.84, 	0,	  0,
0, 	    0,	  0.51,	0.15,
0,      0.14, 0.43, 0.44
), byrow=4, ncol=4)
matU1
matF1=matrix(c(
0, 	  0,	  0,    0.14,
0,	  0, 	  0,	  0,
0, 	  0,	  0,	  0,
0,    0,    0,    0
), byrow=4, ncol=4)
matF1
TF1=matU1+matF1
TF1
lambda(TF1)
TF1
eigen(TF)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
box <- c(rep(1,10),rep(2,5),rep(3,2))  # define what's in the lottery ball machine (10 "1" balls, 5 "2" balls and 2 "3" balls)
box
