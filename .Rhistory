rlnorm(5,meanlog=1.5,sdlog=0.39)    # ¡por ejemplo! (¡recuerde cambiar el parámetro "meanlog" por el valor que identificó anteriormente!)
library(MASS)
fitdistr(hatch_perfem,"log-normal")
############
# Trate de identificar una distribución logarítmica normal de números aleatorios para representar la 'canvasback duck' data
## first, plot a histogram of the data from the 20-year study
hist(hatch_perfem,freq=F,main="Histogram of avg number hatched per female",xlab="possibilities",ylab="probability",xlim=c(0,10),ylim=c(0,1))
## ahora, superponga una distribución de probabilidad logarítmica normal con parámetros arbitrarios (meanlog y sdlog). Esto es sólo un punto de partida.
curve(dlnorm(x,meanlog=1.5,sdlog=0.39),col="green",lty=2,lwd=2,add=T)
curve(dlnorm(x,meanlog=1.8,sdlog=0.39),col="green",lty=2,lwd=2,add=T)
curve(dlnorm(x,meanlog=1,sdlog=0.39),col="red",lty=2,lwd=2,add=T) # try a different value...
#### ¡Siga cambiando el valor de 'meanlog' hasta que encuentre los mejores parámetros que se ajusten a los datos!
#### Una vez que encuentre los parámetros que mejor se ajusten, genere 5 números aleatorios a partir de esta distribución usando la función "rlnorm ()" en R.
rlnorm(5,meanlog=1.5,sdlog=0.39)    # ¡por ejemplo! (¡recuerde cambiar el parámetro "meanlog" por el valor que identificó anteriormente!)
############
# Trate de identificar una distribución logarítmica normal de números aleatorios para representar la 'canvasback duck' data
## first, plot a histogram of the data from the 20-year study
hist(hatch_perfem,freq=F,main="Histogram of avg number hatched per female",xlab="possibilities",ylab="probability",xlim=c(0,10),ylim=c(0,1))
## ahora, superponga una distribución de probabilidad logarítmica normal con parámetros arbitrarios (meanlog y sdlog). Esto es sólo un punto de partida.
curve(dlnorm(x,meanlog=1.5,sdlog=0.39),col="green",lty=2,lwd=2,add=T)
curve(dlnorm(x,meanlog=1.8,sdlog=0.39),col="green",lty=2,lwd=2,add=T)
curve(dlnorm(x,meanlog=2.0,sdlog=0.39),col="red",lty=2,lwd=2,add=T) # try a different value...
#### ¡Siga cambiando el valor de 'meanlog' hasta que encuentre los mejores parámetros que se ajusten a los datos!
#### Una vez que encuentre los parámetros que mejor se ajusten, genere 5 números aleatorios a partir de esta distribución usando la función "rlnorm ()" en R.
rlnorm(5,meanlog=1.5,sdlog=0.39)    # ¡por ejemplo! (¡recuerde cambiar el parámetro "meanlog" por el valor que identificó anteriormente!)
rlnorm(5,meanlog=1.5,sdlog=0.39)    # ¡por ejemplo! (¡recuerde cambiar el parámetro "meanlog" por el valor que identificó anteriormente!)
library(MASS)
fitdistr(hatch_perfem,"log-normal")
install.packages(c("backports", "bayestestR", "broom", "cli", "conquer", "crayon", "fda", "future", "generics", "labelled", "lattice", "mgcv", "nlme", "ragg", "robust", "sessioninfo", "survival", "systemfonts", "tzdb", "usethis", "uuid"))
fitdistr(hatch_perfem,"lognormal")
hatch_perfem/5
hacth_5_years=hatch_perfem/5
hatch_5_years=hatch_perfem/5
fitdistr(hacth_perfem,"log-normal")
fitdistr(hatch_5_years,"log-normal")
rlnorm(1000, -0.92822498, 0.38756090)
data=rlnorm(1000, -0.92822498, 0.38756090)
e^data
data
log2(data)
log(2)
c=log(2)
exp(c)
exp(data)
rlnorm(5,meanlog=1.5,sdlog=0.39)    # ¡por ejemplo! (¡recuerde cambiar el parámetro "meanlog" por el valor que identificó anteriormente!)
hatch_5_years=hatch_perfem/5
fitdistr(hatch_5_years,"log-normal")
data=rlnorm(1000, -0.92822498, 0.38756090)
exp(data)  # USe exp to convert he values from lognotmal to numbers again.
#c=log(2)
#exp(c)
rbeta(10, 2.5, 6)
round(rbeta(10, 2.5, 6), 3)
Larva_supevivencia= c(0.184, 0.093, 0.355, 0.344, 0.295, 0.326, 0.117, 0.148, 0.171, 0.257)
fitdistr(Larva_supevivencia,"beta")
Larva_supevivencia=c(0.184, 0.093, 0.355, 0.344, 0.295, 0.326, 0.117, 0.148, 0.171, 0.257)
fitdistr(Larva_supevivencia,"beta")
install.packages("fitdistrplus")
library(fitdistrplus)
fitdistr(hatch_perfem,"log-normal")
fitdistr(Larva_supevivencia,"beta")
fitdist(Larva_supevivencia,"beta")
plot(fit, las=1)
fit=fitdist(Larva_supevivencia,"beta")
plot(fit, las=1)
Larva_supevivencia=c(0.184, 0.093, 0.355, 0.344, 0.295, 0.326, 0.207, 0.148, 0.171, 0.257)
fit=fitdist(Larva_supevivencia,"beta")
plot(fit, las=1)
fit
plot(fit, las=1)
beta_mom <- function(x) {
m_x <- mean(x, na.rm = TRUE)
s_x <- sd(x, na.rm = TRUE)
alpha <- m_x*((m_x*(1 - m_x)/s_x^2) - 1)
beta <- (1 - m_x)*((m_x*(1 - m_x)/s_x^2) - 1)
return(list(alpha = alpha, beta = beta))
}
beta_mom(x)
Larva_supevivencia=c(0.184, 0.093, 0.355, 0.344, 0.295, 0.326, 0.207, 0.148, 0.171, 0.257)
beta_mom(Larva_supevivencia)
Larva_supevivencia=c(0.184, 0.113, 0.355, 0.344, 0.295, 0.326, 0.207, 0.148, 0.171, 0.257)
beta_mom(Larva_supevivencia)
Larva_supevivencia=c(0.184, 0.113, 0.355, 0.344, 0.295, 0.226, 0.207, 0.148, 0.171, 0.257)
beta_mom(Larva_supevivencia)
fit=fitdist(Larva_supevivencia,"beta")
fit
plot(fit, las=1)
Larva_supevivencia=c(0.184, 0.113, 0.355, 0.344, 0.295, 0.226, 0.207, 0.178, 0.171, 0.257)
beta_mom(Larva_supevivencia)
fit=fitdist(Larva_supevivencia,"beta")
fit
plot(fit, las=1)
### Binomial random number generator
rbinom(1,size=10,prob=0.5)    # note: "size" is the number of coin flips, and "prob" is the probability of coming up 'heads'
### Binomial random number generator
rbinom(100,size=10,prob=0.5)    # note: "size" is the number of coin flips, and "prob" is the probability of coming up 'heads'
### Binomial random number generator
rbinom(1,size=10,prob=0.5)    # note: "size" is the number of coin flips, and "prob" is the probability of coming up 'heads'
### Binomial random number generator
rbinom(1,size=10,prob=0.5)    # note: "size" is the number of coin flips, and "prob" is the probability of coming up 'heads'
### Binomial random number generator
rbinom(1,size=10,prob=0.5)    # note: "size" is the number of coin flips, and "prob" is the probability of coming up 'heads'
### Binomial random number generator
rbinom(1,size=10,prob=0.5)    # note: "size" is the number of coin flips, and "prob" is the probability of coming up 'heads'
### Binomial random number generator
rbinom(1,size=10,prob=0.5)    # note: "size" is the number of coin flips, and "prob" is the probability of coming up 'heads'
### Binomial random number generator
rbinom(1,size=10,prob=0.5)    # note: "size" is the number of coin flips, and "prob" is the probability of coming up 'heads'
### Poisson random number generator
rpois(1,lambda=4.1)     # note: "lambda" represents the mean (and variance!) of the Poisson distribution
### Poisson random number generator
rpois(1,lambda=4.1)     # note: "lambda" represents the mean (and variance!) of the Poisson distribution
### Poisson random number generator
rpois(10,lambda=4.1)     # note: "lambda" represents the mean (and variance!) of the Poisson distribution
### Poisson random number generator
rpois(1,lambda=4.1)     # note: "lambda" represents the mean (and variance!) of the Poisson distribution
### Uniform random number generator
runif(1,min=1,max=3.5)   # "min" and "max" are pretty obvious!
### Uniform random number generator
runif(1,min=1,max=3.5)   # "min" and "max" are pretty obvious!
### Uniform random number generator
runif(1,min=1,max=3.5)   # "min" and "max" are pretty obvious!
### Uniform random number generator
runif(1,min=1,max=3.5)   # "min" and "max" are pretty obvious!
### Uniform random number generator
runif(1,min=1,max=3.5)   # "min" and "max" are pretty obvious!
### Uniform random number generator
runif(1,min=1,max=3.5)   # "min" and "max" are pretty obvious!
### beta random number generator (bounded between 0 and 1- just like survival rate!)
rbeta(1,shape1=10,shape2=3)  # beta distribution is defined by "shape1" and "shape2", which together define the mean and spread within the range from 0 to 1.
### beta random number generator (bounded between 0 and 1- just like survival rate!)
rbeta(1,shape1=10,shape2=3)  # beta distribution is defined by "shape1" and "shape2", which together define the mean and spread within the range from 0 to 1.
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
remotes::install_github('yihui/tinytex')
#install.packages(c('tinytex', dependencies=T))
##############
# Demostración PVA
##############
# PASO 1: conceptualice la historia de vida (estamos modelando esta población como un modelo estocástico simple de una etapa con dependencia de la densidad)
# PASO 2: parametrizar el modelo
####
# Parámetros básicos de la historia de vida
####
R_max <- 1.15       # Tasa máxima de crecimiento
Init_N <- 51        # Abundancia inicial
K <- 175            # CCapacidad de carga
####
# Estocasticidad ambiental
####
SD_anngrowth <- 0.11  # desviación estándar de la tasa de crecimiento anual
####
# Densidad-dependencia (modelo de Ricker)
####
Ricker <- function(prev_abund){       # esta es una función para calcular la abundancia del próximo año - incluye estocasticidad env
prev_abund * exp(log(rnorm(1,R_max,SD_anngrowth))*(1-(prev_abund/K)))
}
####
# Catástrofe
####
Flood_prob <- 0.05      # 5% probabilidad de una gran inundación
Flood_lambda <- 0.25    # 25% de la población puede sobrevivir a una inundación
# PASO 3: agregue estructura espacial (no se aplica aquí)
# PASO 4: ¡simular!
####
# Parámetros de simulación básicos
####
nyears <- 100     # número de años
nreps <- 500      # número de réplicas
PVAdemo <- function(nreps,nyears,Init_N,R_max,K,Flood_prob,Flood_lambda){
#browser()
PopArray2 <- array(0,dim=c((nyears+1),nreps))   # configurar matriz de almacenamiento
## empezar a recorrer las réplicas
for(rep in 1:nreps){
# establecer abundancia inicial
PopArray2[1,rep] <- Init_N     # establecer la abundancia inicial
### recorrer años: loop through years
for(y in 2:(nyears+1)){
### estocasticidad y d-d
nextyear <- max(0,trunc(Ricker(PopArray2[y-1,rep])))
### catástrofe
if(runif(1)<Flood_prob) nextyear <- nextyear*Flood_lambda
PopArray2[y,rep] <- nextyear
}
}
return(PopArray2)
}
### Run the PVA!
Default <- PVAdemo(nreps,nyears,Init_N,R_max,K,Flood_prob,Flood_lambda)
# PASO 5: resultados
############
# Visualización gráfica
PlotCloud <- function(simdata){
plot(c(1:101),simdata[,1],col=gray(0.7),type="l",ylim=c(0,max(simdata)),xlab="Years",ylab="Abundance")
for(r in 2:ncol(simdata)){
lines(c(1:101),simdata[,r],col=gray(0.7),type="l")
}
}
PlotCloud(Default)
# Visualice las tasas de extinción a lo largo del tiempo
Extinction_byyear <- function(simdata){
apply(simdata,1,function(t)  length(which(t==0)))/ncol(simdata)
}
plot(c(1:101),Extinction_byyear(Default),type="l",lwd=2,xlab="year",ylab="extinction risk")
abline(h=0.05,col="red",lwd=2)
# visualizar la abundancia final después de 100 años en relación con la abundancia inicial
hist(Default[nrow(Default),],xlab="Final abundance after 100 years",ylab="Number of replicates",main="")
abline(v=Init_N,col="green",lwd=2)
# plot probabilities of different severities of declinegraficar las probabilidades de diferentes grados de declive
declines <- seq(0,100,by=1)
declineprob <- numeric(length(declines))
for(s in 1:length(declines)){
declineprob[s] <- length(which(Default[nrow(Default),]<(Init_N-(declines[s]/100)*Init_N)))/ncol(Default)
}
plot(declines,declineprob,type="l",lwd=2,xlab="Decline threshold (percent)",ylab="Probability of falling below threshold")
abline(v=25,col="red",lwd=2)
# Grafique el riesgo de extinción en función de la gravedad de las inundaciones
Exctinction_risk <- function(simdata){
length(which(simdata[nrow(simdata),]==0))/ncol(simdata)
}
flood_lambdas <- seq(0.9,0.1,by=-0.05)
all_scenarios <- numeric(length(flood_lambdas))
for(scenario in 1:length(flood_lambdas)){
PVA <- PVAdemo(nreps,nyears,Init_N,R_max,K,Flood_prob,flood_lambdas[scenario])
all_scenarios[scenario] <- Exctinction_risk(PVA)
}
plot(flood_lambdas,all_scenarios,type="p",cex=2,xlab="flood impact (lambda in flood year)",ylab="extinction risk")
abline(h=0.05,col="red",lwd=2)
#install.packages(c('tinytex', dependencies=T))
##############
# Demostración PVA
##############
# PASO 1: conceptualice la historia de vida (estamos modelando esta población como un modelo estocástico simple de una etapa con dependencia de la densidad)
# PASO 2: parametrizar el modelo
####
# Parámetros básicos de la historia de vida
####
R_max <- 1.15       # Tasa máxima de crecimiento
Init_N <- 51        # Abundancia inicial
K <- 175            # Capacidad de carga
####
# Estocasticidad ambiental
####
SD_anngrowth <- 0.11  # desviación estándar de la tasa de crecimiento anual
####
# Densidad-dependencia (modelo de Ricker)
####
Ricker <- function(prev_abund){       # esta es una función para calcular la abundancia del próximo año - incluye estocasticidad env
prev_abund * exp(log(rnorm(1,R_max,SD_anngrowth))*(1-(prev_abund/K)))
}
####
# Catástrofe
####
Flood_prob <- 0.05      # 5% probabilidad de una gran inundación
Flood_lambda <- 0.25    # 25% de la población puede sobrevivir a una inundación
# PASO 3: agregue estructura espacial (no se aplica aquí)
# PASO 4: ¡simular!
####
# Parámetros de simulación básicos
####
nyears <- 100     # número de años
nreps <- 500      # número de réplicas
PVAdemo <- function(nreps,nyears,Init_N,R_max,K,Flood_prob,Flood_lambda){
#browser()
PopArray2 <- array(0,dim=c((nyears+1),nreps))   # configurar matriz de almacenamiento
## empezar a recorrer las réplicas
for(rep in 1:nreps){
# establecer abundancia inicial
PopArray2[1,rep] <- Init_N     # establecer la abundancia inicial
### recorrer años: loop through years
for(y in 2:(nyears+1)){
### estocasticidad y d-d
nextyear <- max(0,trunc(Ricker(PopArray2[y-1,rep])))
### catástrofe
if(runif(1)<Flood_prob) nextyear <- nextyear*Flood_lambda
PopArray2[y,rep] <- nextyear
}
}
return(PopArray2)
}
### Run the PVA!
Default <- PVAdemo(nreps,nyears,Init_N,R_max,K,Flood_prob,Flood_lambda)
# PASO 5: resultados
############
# Visualización gráfica
PlotCloud <- function(simdata){
plot(c(1:101),simdata[,1],col=gray(0.7),type="l",ylim=c(0,max(simdata)),xlab="Years",ylab="Abundance")
for(r in 2:ncol(simdata)){
lines(c(1:101),simdata[,r],col=gray(0.7),type="l")
}
}
PlotCloud(Default)
# Visualice las tasas de extinción a lo largo del tiempo
Extinction_byyear <- function(simdata){
apply(simdata,1,function(t)  length(which(t==0)))/ncol(simdata)
}
plot(c(1:101),Extinction_byyear(Default),type="l",lwd=2,xlab="year",ylab="extinction risk")
abline(h=0.05,col="red",lwd=2)
# visualizar la abundancia final después de 100 años en relación con la abundancia inicial
hist(Default[nrow(Default),],xlab="Final abundance after 100 years",ylab="Number of replicates",main="")
abline(v=Init_N,col="green",lwd=2)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
############################################################
####                                                    ####
####  BIOL4558, Lecture 12                              ####
####                                                    ####
#### Raymond L. Tremblay                                ####
####  Universidad de Puerto Rico                        ####
####                                                    ####
############################################################
############################################################
####  Análisis de viabilidad poblacional                ####
############################################################
#install.packages(c('tinytex', dependencies=T))
##############
# Demostración PVA
##############
# PASO 1: conceptualice la historia de vida (estamos modelando esta población como un modelo estocástico simple de una etapa con dependencia de la densidad)
# PASO 2: parametrizar el modelo
####
# Parámetros básicos de la historia de vida
####
R_max <- 1.15       # Tasa máxima de crecimiento
Init_N <- 500        # Abundancia inicial
K <- 175            # Capacidad de carga
####
# Estocasticidad ambiental
####
SD_anngrowth <- 0.11  # desviación estándar de la tasa de crecimiento anual
####
# Densidad-dependencia (modelo de Ricker)
####
Ricker <- function(prev_abund){       # esta es una función para calcular la abundancia del próximo año - incluye estocasticidad env
prev_abund * exp(log(rnorm(1,R_max,SD_anngrowth))*(1-(prev_abund/K)))
}
####
# Catástrofe
####
Flood_prob <- 0.05      # 5% probabilidad de una gran inundación
Flood_lambda <- 0.25    # 25% de la población puede sobrevivir a una inundación
#remotes::install_github('yihui/tinytex')
# PASO 3: agregue estructura espacial (no se aplica aquí)
# PASO 4: ¡simular!
####
# Parámetros de simulación básicos
####
nyears <- 100     # número de años
nreps <- 500      # número de réplicas
PVAdemo <- function(nreps,nyears,Init_N,R_max,K,Flood_prob,Flood_lambda){
#browser()
PopArray2 <- array(0,dim=c((nyears+1),nreps))   # configurar matriz de almacenamiento
## empezar a recorrer las réplicas
for(rep in 1:nreps){
# establecer abundancia inicial
PopArray2[1,rep] <- Init_N     # establecer la abundancia inicial
### recorrer años: loop through years
for(y in 2:(nyears+1)){
### estocasticidad y d-d
nextyear <- max(0,trunc(Ricker(PopArray2[y-1,rep])))
### catástrofe
if(runif(1)<Flood_prob) nextyear <- nextyear*Flood_lambda
PopArray2[y,rep] <- nextyear
}
}
return(PopArray2)
}
### Run the PVA!
Default <- PVAdemo(nreps,nyears,Init_N,R_max,K,Flood_prob,Flood_lambda)
# PASO 5: resultados
############
# Visualización gráfica
PlotCloud <- function(simdata){
plot(c(1:101),simdata[,1],col=gray(0.7),type="l",ylim=c(0,max(simdata)),xlab="Years",ylab="Abundance")
for(r in 2:ncol(simdata)){
lines(c(1:101),simdata[,r],col=gray(0.7),type="l")
}
}
PlotCloud(Default)
# Visualice las tasas de extinción a lo largo del tiempo
Extinction_byyear <- function(simdata){
apply(simdata,1,function(t)  length(which(t==0)))/ncol(simdata)
}
plot(c(1:101),Extinction_byyear(Default),type="l",lwd=2,xlab="year",ylab="extinction risk")
abline(h=0.05,col="red",lwd=2)
# visualizar la abundancia final después de 100 años en relación con la abundancia inicial
hist(Default[nrow(Default),],xlab="Final abundance after 100 years",ylab="Number of replicates",main="")
abline(v=Init_N,col="green",lwd=2)
# plot probabilities of different severities of declinegraficar las probabilidades de diferentes grados de declive
declines <- seq(0,100,by=1)
declineprob <- numeric(length(declines))
for(s in 1:length(declines)){
declineprob[s] <- length(which(Default[nrow(Default),]<(Init_N-(declines[s]/100)*Init_N)))/ncol(Default)
}
plot(declines,declineprob,type="l",lwd=2,xlab="Decline threshold (percent)",ylab="Probability of falling below threshold")
abline(v=25,col="red",lwd=2)
# Grafique el riesgo de extinción en función de la gravedad de las inundaciones
Exctinction_risk <- function(simdata){
length(which(simdata[nrow(simdata),]==0))/ncol(simdata)
}
flood_lambdas <- seq(0.9,0.1,by=-0.05)
all_scenarios <- numeric(length(flood_lambdas))
for(scenario in 1:length(flood_lambdas)){
PVA <- PVAdemo(nreps,nyears,Init_N,R_max,K,Flood_prob,flood_lambdas[scenario])
all_scenarios[scenario] <- Exctinction_risk(PVA)
}
plot(flood_lambdas,all_scenarios,type="p",cex=2,xlab="flood impact (lambda in flood year)",ylab="extinction risk")
abline(h=0.05,col="red",lwd=2)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
############################################################
####                                                    ####
####  BIOL4558, Lecture 12                              ####
####                                                    ####
#### Raymond L. Tremblay                                ####
####  Universidad de Puerto Rico                        ####
####                                                    ####
############################################################
############################################################
####  Análisis de viabilidad poblacional                ####
############################################################
#install.packages(c('tinytex', dependencies=T))
##############
# Demostración PVA
##############
# PASO 1: conceptualice la historia de vida (estamos modelando esta población como un modelo estocástico simple de una etapa con dependencia de la densidad)
# PASO 2: parametrizar el modelo
####
# Parámetros básicos de la historia de vida
####
R_max <- 1.15       # Tasa máxima de crecimiento
Init_N <- 500        # Abundancia inicial
K <- 500            # Capacidad de carga
####
# Estocasticidad ambiental
####
SD_anngrowth <- 0.11  # desviación estándar de la tasa de crecimiento anual
####
# Densidad-dependencia (modelo de Ricker)
####
Ricker <- function(prev_abund){       # esta es una función para calcular la abundancia del próximo año - incluye estocasticidad env
prev_abund * exp(log(rnorm(1,R_max,SD_anngrowth))*(1-(prev_abund/K)))
}
####
# Catástrofe
####
Flood_prob <- 0.05      # 5% probabilidad de una gran inundación
Flood_lambda <- 0.25    # 25% de la población puede sobrevivir a una inundación
#remotes::install_github('yihui/tinytex')
# PASO 3: agregue estructura espacial (no se aplica aquí)
# PASO 4: ¡simular!
####
# Parámetros de simulación básicos
####
nyears <- 100     # número de años
nreps <- 500      # número de réplicas
PVAdemo <- function(nreps,nyears,Init_N,R_max,K,Flood_prob,Flood_lambda){
#browser()
PopArray2 <- array(0,dim=c((nyears+1),nreps))   # configurar matriz de almacenamiento
## empezar a recorrer las réplicas
for(rep in 1:nreps){
# establecer abundancia inicial
PopArray2[1,rep] <- Init_N     # establecer la abundancia inicial
### recorrer años: loop through years
for(y in 2:(nyears+1)){
### estocasticidad y d-d
nextyear <- max(0,trunc(Ricker(PopArray2[y-1,rep])))
### catástrofe
if(runif(1)<Flood_prob) nextyear <- nextyear*Flood_lambda
PopArray2[y,rep] <- nextyear
}
}
return(PopArray2)
}
### Run the PVA!
Default <- PVAdemo(nreps,nyears,Init_N,R_max,K,Flood_prob,Flood_lambda)
# PASO 5: resultados
############
# Visualización gráfica
PlotCloud <- function(simdata){
plot(c(1:101),simdata[,1],col=gray(0.7),type="l",ylim=c(0,max(simdata)),xlab="Years",ylab="Abundance")
for(r in 2:ncol(simdata)){
lines(c(1:101),simdata[,r],col=gray(0.7),type="l")
}
}
PlotCloud(Default)
# Visualice las tasas de extinción a lo largo del tiempo
Extinction_byyear <- function(simdata){
apply(simdata,1,function(t)  length(which(t==0)))/ncol(simdata)
}
plot(c(1:101),Extinction_byyear(Default),type="l",lwd=2,xlab="year",ylab="extinction risk")
abline(h=0.05,col="red",lwd=2)
# visualizar la abundancia final después de 100 años en relación con la abundancia inicial
hist(Default[nrow(Default),],xlab="Final abundance after 100 years",ylab="Number of replicates",main="")
abline(v=Init_N,col="green",lwd=2)
# plot probabilities of different severities of declinegraficar las probabilidades de diferentes grados de declive
declines <- seq(0,100,by=1)
declineprob <- numeric(length(declines))
for(s in 1:length(declines)){
declineprob[s] <- length(which(Default[nrow(Default),]<(Init_N-(declines[s]/100)*Init_N)))/ncol(Default)
}
plot(declines,declineprob,type="l",lwd=2,xlab="Decline threshold (percent)",ylab="Probability of falling below threshold")
abline(v=25,col="red",lwd=2)
# Grafique el riesgo de extinción en función de la gravedad de las inundaciones
Exctinction_risk <- function(simdata){
length(which(simdata[nrow(simdata),]==0))/ncol(simdata)
}
flood_lambdas <- seq(0.9,0.1,by=-0.05)
all_scenarios <- numeric(length(flood_lambdas))
for(scenario in 1:length(flood_lambdas)){
PVA <- PVAdemo(nreps,nyears,Init_N,R_max,K,Flood_prob,flood_lambdas[scenario])
all_scenarios[scenario] <- Exctinction_risk(PVA)
}
plot(flood_lambdas,all_scenarios,type="p",cex=2,xlab="flood impact (lambda in flood year)",ylab="extinction risk")
abline(h=0.05,col="red",lwd=2)
