##   [1] 1.136
( i1 <- inertia(Tort, Tortvec1) )
##   [1] 1.777
## Copiar el chunk ariba
Tortp1.1s <- project(Tort, Tortvec1, time = 100,
standard.A = TRUE, standard.vec = TRUE)
Tortpws <- project(Tort, Tortw, time = 100,
standard.A = TRUE, standard.vec = TRUE)
plot(Tortp1.1s, log = "y")
lines(Tortpws, lty = 2)
points(c(1, 100), c(r1, i1), pch = 3, col = "red")
TortAMP <- c(1, 1, 2, 3, 5, 8, 13, 21) #a population that amplifies
TortATT <- c(21, 13, 8, 5, 3, 2, 1, 1) #a population that attenuates
TortBTH <- c(0, 0, 0, 1, 0, 0, 0, 0) #a population that does both
Tortvec3 <- cbind(AMP = TortAMP,
ATT = TortATT,
BTH = TortBTH)
Tortp3.1 <- project(Tort, Tortvec3, time = 100,
standard.A = TRUE, standard.vec = TRUE)
plot(Tortp3.1, log = "y"); lines(Tortpws, lty = 2)
( r3 <- apply(Tortvec3, 2, reac, A = Tort) )
##      AMP    ATT    BTH
##   2.6319 0.9153 0.8757
( r3t <- rep(1, 3) )
##   [1] 1 1 1
( i3 <- apply(Tortvec3, 2, inertia, A = Tort) )
##      AMP    ATT    BTH
##   4.1442 0.9123 1.8019
( i3t <- rep(100, 3) )
##   [1] 100 100 100
( max3 <- apply(Tortvec3[,c(1,3)], 2, maxamp, A = Tort) )
##     AMP   BTH
##   5.111 1.962
( max3t <- apply(Tortvec3[,c(1,3)], 2, function(x){
maxamp(vector = x, A = Tort, return.t = TRUE)$t}) )
##   AMP BTH
##     6  13
( min3 <- apply(Tortvec3[,c(2,3)], 2, maxatt, A = Tort) )
##      ATT    BTH
##   0.8377 0.7261
( min3t <- apply(Tortvec3[,c(2,3)], 2, function(x){
maxatt(vector = x, A = Tort, return.t = TRUE )$t}) )
##   ATT BTH
##     4   3
points(c(r3t, i3t, max3t, min3t),
c(r3, i3, max3, min3),
pch = 3, col = "red")
plot(Tortp1.1s, log = "y", bounds = TRUE)
plot(project(Tort, standard.A = TRUE), log = "y")
Tortpd <- project(Tort, "diri", time = 31,
standard.A = TRUE)
##   Warning in .recacheSubclasses(def@className, def, env): undefined subclass
##   "numericVector" of class "Mnumeric"; definition not updated
plot(Tortpd, plottype = "shady", bounds = T, log = "y")
pr1 <- project(TF, vector=n0, time=24)
#Plot the projection. This uses an S3 plotting
#method for projections. For info, see '?plot.projection'.
plot(pr1)
TF
pr1 <- project(TF, vector=n0, time=24)
#Plot the projection. This uses an S3 plotting
#method for projections. For info, see '?plot.projection'.
plot(pr1)
TF
eigs <- eigen(TF)
eigs # los diferentes eigenvalue de la matrix. El que responde al crecimiento intrinsico de la población es la parte mayor real.
truelambda(TF) # Con el paquete popdemo
lambda(TF) # con el paquete popbio
popbio::lambda(TF) # con el paquete popbio
eigs <- eigen(TF)
eigs # los diferentes eigenvalue de la matrix. El que responde al crecimiento intrinsico de la población es la parte mayor real.
popbio::lambda(TF) # con el paquete popbio
w <- stable.stage(TF)
w
w <- stable.stage(TF)
library(popbio)
w <- stable.stage(TF)
w
matACc
stable.stage(matACc) # en el paquete popdemo
eigen(TF)
eigen(TF)
# Calcular a mano el damping.ratio
1.0296/abs(0.7709)
dr(TF, return.time=TRUE, x=10)
eigen(matACc)
0.95158/abs(0.711699)
dr(matACc)
dr(matACc, return.time=TRUE, x=10) # damping ratio
# convt, en popdemo
n=c(1000,0,0,0, 0)
convt(matACc, accuracy=1e-3, vector=n) # Convergence time to Stable Stage Distribution from an invasive species starting with smallest size
n1=c(238,648,103,7, 3)
convt(matACc, accuracy=1e-3, vector=n1) # Convergence time to Stable Stage Distribution when close to Stable Stage
# convt, en popdemo
n=c(1000,0,0,0, 0)
convt(matACc, accuracy=1e-3, vector=n) # Convergence time to Stable Stage Distribution from an invasive species starting with smallest size
n1=c(238,648,103,7, 3)
convt(matACc, accuracy=1e-3, vector=n1) # Convergence time to Stable Stage Distribution when close to Stable Stage
n2=c(0,0,0,0,1000)
convt(matACc, accuracy=1e-3, vector=n2) # Convergence time to Stable Stage Distribution when starting with an invasive species of adults
library(popdemoDev)
detach("package:popdemoDev", unload = TRUE)
library(popdemoDev)
detach("package:popdemoDev", unload = TRUE)
# Install dependencies from CRAN:
install.packages(c("devtools", "expm", "MCMCpack", "markovchain"))
# Install stable version from GitHub (recommended):
# NOTE don't forget to change the version number!
library(popdemo)
# Install development version 'popdemoDev' (not recommended):
devtools::install_github("iainmstott/popdemo/Dev/popdemoDev", ref = "development")
install.packages(c("devtools", "expm", "MCMCpack", "markovchain"))
#library(popdemoDev)
data(Tort)
Tort
Tortvec1 <- runif(8)
Tortvec1 <- Tortvec1/sum(Tortvec1) #scales the vector to sum to 1
( Tortp1.1 <- project(Tort, Tortvec1, time = 100) )
plot(Tortp1.1, log = "y")
plot(Tortp1.1)
plot(Tortp1.1, log = "y")
( Tortp1.1 <- project(Tort, Tortvec1, time = 20) )
plot(Tortp1.1, log = "y")
Tortvec1 <- runif(8) # el 8 se refiere que hay 8 etapas
Tortvec1 <- Tortvec1/sum(Tortvec1) #scales the vector to sum to 1
( Tortp1.1 <- project(Tort, Tortvec1, time = 20) )
plot(Tortp1.1, log = "y")
Tortvec1 <- runif(8) # el 8 se refiere que hay 8 etapas
Tortvec1 <- Tortvec1/sum(Tortvec1) #scales the vector to sum to 1
( Tortp1.1 <- project(Tort, Tortvec1, time = 200) )
plot(Tortp1.1, log = "y")
Tortvec1 <- runif(8) # el 8 se refiere que hay 8 etapas
Tortvec1 <- Tortvec1/sum(Tortvec1) #scales the vector to sum to 1
( Tortp1.1 <- project(Tort, Tortvec1, time = 100) )
plot(Tortp1.1, log = "y")
vec(Tortp1.1)[1:11,1 ]
vec(Tortp1.1)[1:11,1:5 ]
vec(Tortp1.1)[1:11, ]
Tortvec1 <- runif(8) # el 8 se refiere que hay 8 etapas
Tortvec1 <- Tortvec1/sum(Tortvec1) #scales the vector to sum to 1
( Tortp1.1 <- project(Tort, Tortvec1, time = 11) )
plot(Tortp1.1, log = "y")
vec(Tortp1.1)[1:11, ]
vec(Tortp1.1)[1:11, ]
vec(Tortp1.1)[1:11, ]
vec(Tortp1.1)[1:11, ]
Tortvec1 <- runif(8) # el 8 se refiere que hay 8 etapas
Tortvec1 <- Tortvec1/sum(Tortvec1) #scales the vector to sum to 1
( Tortp1.1 <- project(Tort, Tortvec1, time = 11) )
plot(Tortp1.1, log = "y")
vec(Tortp1.1)[1:11, ]
vec(Tortp1.1)[1:11, ]
Tortvec1 <- runif(8) # el 8 se refiere que hay 8 etapas
Tortvec1 <- Tortvec1/sum(Tortvec1) #scales the vector to sum to 1
( Tortp1.1 <- project(Tort, Tortvec1, time = 11) )
plot(Tortp1.1, log = "y")
vec(Tortp1.1)[1:11, ]
Tortvec1 <- runif(8) # el 8 se refiere que hay 8 etapas
Tortvec1 <- Tortvec1/sum(Tortvec1) #scales the vector to sum to 1
( Tortp1.1 <- project(Tort, Tortvec1, time = 100) )
plot(Tortp1.1, log = "y")
vec(Tortp1.1)[1:11, ]
Tortvec1 <- runif(8) # el 8 se refiere que hay 8 etapas
Tortvec1 <- Tortvec1/sum(Tortvec1) #scales the vector to sum to 1
( Tortp1.1 <- project(Tort, Tortvec1, time = 100) )
plot(Tortp1.1, log = "y")
vec(Tortp1.1)[1:11, ]
vec(Tortp1.1)[1:11, ]
vec(Tortp1.1)[, 2]
vec(Tortp1.1)[, 2]
vec(Tortp1.1)[, 2]
vec(Tortp1.1)[1:11, ]
vec(Tortp1.1)[1:11, ]
vec(Tortp1.1)[1:11, ]
vec(Tortp1.1)[1:11, ]
Tortvec1 <- runif(8) # el 8 se refiere que hay 8 etapas
Tortvec1 <- Tortvec1/sum(Tortvec1) #scales the vector to sum to 1
( Tortp1.1 <- project(Tort, Tortvec1, time = 11) )
plot(Tortp1.1, log = "y")
vec(Tortp1.1)[1:11, ]
vec(Tortp1.1)[1:11, ]
set.seed(1234)
Tortvec1 <- runif(8) # el 8 se refiere que hay 8 etapas
Tortvec1 <- Tortvec1/sum(Tortvec1) #scales the vector to sum to 1
( Tortp1.1 <- project(Tort, Tortvec1, time = 11) )
plot(Tortp1.1, log = "y")
vec(Tortp1.1)[1:11, ]
#set.seed(1234)
Tortvec1 <- runif(8) # el 8 se refiere que hay 8 etapas
Tortvec1 <- Tortvec1/sum(Tortvec1) #scales the vector to sum to 1
( Tortp1.1 <- project(Tort, Tortvec1, time = 11) )
plot(Tortp1.1, log = "y")
vec(Tortp1.1)[1:11, ]
set.seed(1234)
Tortvec1 <- runif(8) # el 8 se refiere que hay 8 etapas
Tortvec1 <- Tortvec1/sum(Tortvec1) #scales the vector to sum to 1
( Tortp1.1 <- project(Tort, Tortvec1, time = 11) )
plot(Tortp1.1, log = "y")
vec(Tortp1.1)[1:11, ]
Tort
vec(Tortp1.1)[, 2]
Tort
vec(Tortp1.1)[1:11, ]
Tort
stable.stage(Tort)
vec(Tortp1.1)[1:11, ]
vec(Tortp1.1)[1:100, ]
#nT=c(10000, 500, 300, .....)
stable.stage(Tort)
vec(Tortp1.1)[1:100, ]
vec(Tortp1.1)[1:20, ]
set.seed(1234)
Tortvec1 <- runif(8) # el 8 se refiere que hay 8 etapas
Tortvec1 <- Tortvec1/sum(Tortvec1) #scales the vector to sum to 1
( Tortp1.1 <- project(Tort, Tortvec1, time = 11) )
plot(Tortp1.1, log = "y")
#nT=c(10000, 500, 300, .....)
stable.stage(Tort)
vec(Tortp1.1)[1:20, ]
vec(Tortp1.1)[1:11, ]
vec(Tortp1.1)[1:15, ]
vec(Tortp1.1)[1:11, ]
vec(Tortp1.1)[, 8]
vec(Tortp1.1)[, 2]
eigs(Tort, "all")
Tort
eigs(Tort, "all")
#To show (e.g.) means, you need geom_col()
df <- data.frame(trt = c("a", "b", "c", "d", "e"), outcome = c(5, 4, 6, 2, 1))
p1=ggplot(df, aes(trt, outcome)) +
geom_col(aes(fill=trt))+
guides(fill=FALSE)+theme_void() + theme_transparent()
library(Rage)
matU1=matrix(c(
0.43, 	0,	  0,    0.00,
0.38,	0.84, 	0,	  0,
0, 	    0,	  0.51,	0.15,
0,      0.14, 0.43, 0.44
), byrow=4, ncol=4)
matU1
matF1=matrix(c(
0, 	  0,	  0,    0.14,
0,	  0, 	  0,	  0,
0, 	  0,	  0,	  0,
0,    0,    0,    0
), byrow=4, ncol=4)
matF1
TF1=matU1+matF1
TF1
lambda(TF1)
library(Rage)
matU1=matrix(c(
0.43, 	0,	  0,    0.00,
0.38,	0.84, 	0,	  0,
0, 	    0,	  0.51,	0.15,
0,      0.14, 0.43, 0.44
), byrow=4, ncol=4)
matU1
matF1=matrix(c(
0, 	  0,	  0,    0.14,
0,	  0, 	  0,	  0,
0, 	  0,	  0,	  0,
0,    0,    0,    0
), byrow=4, ncol=4)
matF1
TF1=matU1+matF1
TF1
lambda(TF1)
knitr::opts_chunk$set(echo = TRUE)
library(popdemo)
library(popbio)
#remotes::install_github("jonesor/Rage")
library(Rage)
matU=matrix(c(
0.43, 	0,	    0.00,   0.00,
0.38,	  0.84,   0.00,	  0.00,
0, 	    0.00,	  0.51,	  0.15,
0,      0.14,   0.43,   0.84),
byrow=4, ncol=4)
matU
matF=matrix(c(
0, 	  0,	  0,    0.14,
0,	  0, 	  0,	  0,
0, 	  0,	  0,	  0,
0,    0,    0,    0
), byrow=4, ncol=4)
matF
TF=matU+matF
TF
colnames(TF) <- c("plantulas", "juveniles", "A no reprod", "A reprod")
rownames(TF) <- colnames(TF)
TF
orchid_names= c("1_plantulas", "2_juveniles", "3_adulto no reproductivos", "4_adultos reproductivos")
orchid_names_2= c("1", "2", "3", "4")
#stages <- c(TF_TF)
plot_life_cycle(TF)
#plot_life_cycle(TF, stages = orchid_names_2)
TF
library(popbio)
lambda(TF) # crecimiento de 3%
library(Rage)
matU1=matrix(c(
0.43, 	0,	  0,    0.00,
0.38,	0.84, 	0,	  0,
0, 	    0,	  0.51,	0.15,
0,      0.14, 0.43, 0.44
), byrow=4, ncol=4)
matU1
matF1=matrix(c(
0, 	  0,	  0,    0.14,
0,	  0, 	  0,	  0,
0, 	  0,	  0,	  0,
0,    0,    0,    0
), byrow=4, ncol=4)
matF1
TF1=matU1+matF1
TF1
lambda(TF1)
library(Rage)
matU1=matrix(c(
0.43, 	0,	  0,    0.00,
0.38,	0.84, 	0,	  0,
0, 	    0,	  0.51,	0.15,
0,      0.14, 0.43, 0.44
), byrow=4, ncol=4)
matU1
matF1=matrix(c(
0, 	  0,	  0,    0.14,
0,	  0, 	  0,	  0,
0, 	  0,	  0,	  0,
0,    0,    0,    0
), byrow=4, ncol=4)
matF1
TF1=matU1+matF1
TF1
lambda(TF1)
TF1
eigen(TF)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
box <- c(rep(1,10),rep(2,5),rep(3,2))  # define what's in the lottery ball machine (10 "1" balls, 5 "2" balls and 2 "3" balls)
box
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
#############
# Generación de números aleatorios!
#####
# define an arbitrary distribution
box <- c(rep(1,10),rep(2,5),rep(3,2))  # define what's in the lottery ball machine (10 "1" balls, 5 "2" balls and 2 "3" balls)
box
barplot(table(box)/sum(table(box)),ylab="probability",xlab="possibility")  # visualize the distribution of possibilities
# plot a discrete distribution!
xvals <- seq(0,10,1)
xvals
probs <- dbinom(xvals,10,prob=0.3)
probs
probs
#Cual es la suma de la probabilidades?
sum(probs)
names(probs) <- xvals
barplot(probs,ylab="Probability",xlab="Possibilities",main="Binomial distribution (discrete)")
barplot(probs,ylab="Probability",xlab="Possibilities",main="Distribución binomial (discreta)")
barplot(probs,ylab="Probabilidades",xlab="Posibilidades",main="Distribución binomial (discreta)")
library(tidyverse)
library(tidyverse)
caras=c(4,7, 6, 8, 5, 4,3,7,7,2,
9, 3, 5,4, 5, 4, 4,2,6,5)
caras=as_tibble(caras)
caras
ggplot(caras, aes(value))+
geom_histogram(aes(y=..density..))
library(tidyverse)
caras=c(4,7, 6, 8, 5, 4,3,7,7,2,
9, 3, 5,4, 5, 4, 4,2,6,5)
caras=as_tibble(caras)
caras
ggplot(caras, aes(value))+
geom_histogram(aes(y=..density..))
#########
# Distribución de Poisson
xvals <- seq(0,10,1)
probs <- dpois(xvals,lambda=2.2)     # Distribución Poisson
names(probs) <- xvals
barplot(probs,ylab="Probabilidades",xlab="Possibilidades",main="Distribución Poisson (discreta)")
probs <- dpois(xvals,lambda=10.2)     # Distribución Poisson
names(probs) <- xvals
barplot(probs,ylab="Probabilidades",xlab="Possibilidades",main="Distribución Poisson (discreta)")
probs <- dpois(xvals,lambda=1.2)     # Distribución Poisson
names(probs) <- xvals
barplot(probs,ylab="Probabilidades",xlab="Possibilidades",main="Distribución Poisson (discreta)")
probs <- dpois(xvals,lambda=2.2)     # Distribución Poisson
names(probs) <- xvals
barplot(probs,ylab="Probabilidades",xlab="Possibilidades",main="Distribución Poisson (discreta)")
probs <- dpois(xvals,lambda=100)     # Distribución Poisson El lambda es una función que determina las probabilidades
names(probs) <- xvals
barplot(probs,ylab="Probabilidades",xlab="Possibilidades",main="Distribución Poisson (discreta)")
probs
probs <- dpois(xvals,lambda=2.2)     # Distribución Poisson El lambda es una función que determina las probabilidades
names(probs) <- xvals
barplot(probs,ylab="Probabilidades",xlab="Possibilidades",main="Distribución Poisson (discreta)")
################
# DISTRIBUCIONES CONTINUAS
#################
##########
# Distribución uniforme
lower = 0
upper = 10
curve(dunif(x,lower,upper),0,10,ylab="Probability (density)",xlab="Possibilities",main="Uniform distribution (continuous)",ylim=c(0,1))   # probability density
################
# DISTRIBUCIONES CONTINUAS
#################
##########
# Distribución uniforme
lower = 0
upper = 10
curve(dunif(x,lower,upper),0,10,ylab="Probabilidad (densidad)",xlab="Possibilidades",main="Distribución uniforme (continuous)",ylim=c(0,1))   # Distribución uniforme
#########
# Distribución normal
mean = 7.1
stdev = 1.9
curve(dnorm(x,mean,stdev),0,15,ylab="Probabilidades (densidad)",xlab="Possibilidades",main="Distribución normal (continua)")   # probability density
#########
# Distribución normal
x=rnorm(1000000, 0,1 )
x=as.tibble(x)
#x
ggplot(x, aes(value))+
geom_density()
#########
# Distribución normal
x=rnorm(10000, 0,1 )
x=as.tibble(x)
#x
ggplot(x, aes(value))+
geom_density()
############
# Log-normal distribution
meanlog = 1.4
stdevlog = 0.6
curve(dlnorm(x,meanlog,stdevlog),0,15,ylab="Probability (density)",xlab="Possibilities",main="Lognormal distribution (continuous)")   # probability density
hist(rgamma(20,4.1,2))
hist(rgamma(200,4.1,2))
#############
# Demostración: ¡use datos para determinar una distribución!
#############
#############
# Made-up canvasback data- average number of eggs hatched per female for 20 years
hatch_perfem <- c(3.05, 1.45, 0.99, 3.24, 1.49, 1.70, 1.66, 2.32, 0.83, 2.41,
2.33, 1.68, 1.43, 2.74, 2.05, 3.13, 1.90, 3.69, 1.55, 2.79)
hist(hatch_perfem)
############
# Trate de identificar una distribución logarítmica normal de números aleatorios para representar la 'canvasback duck' data
## first, plot a histogram of the data from the 20-year study
hist(hatch_perfem,freq=F,main="Histogram of avg number hatched per female",xlab="possibilities",ylab="probability",xlim=c(0,10),ylim=c(0,1))
## ahora, superponga una distribución de probabilidad logarítmica normal con parámetros arbitrarios (meanlog y sdlog). Esto es sólo un punto de partida.
curve(dlnorm(x,meanlog=1.5,sdlog=0.39),col="green",lty=2,lwd=2,add=T)
curve(dlnorm(x,meanlog=1.8,sdlog=0.39),col="green",lty=2,lwd=2,add=T)
curve(dlnorm(x,meanlog=2.0,sdlog=0.39),col="red",lty=2,lwd=2,add=T) # try a different value...
#### ¡Siga cambiando el valor de 'meanlog' hasta que encuentre los mejores parámetros que se ajusten a los datos!
#### Una vez que encuentre los parámetros que mejor se ajusten, genere 5 números aleatorios a partir de esta distribución usando la función "rlnorm ()" en R.
rlnorm(5,meanlog=1.5,sdlog=0.39)    # ¡por ejemplo! (¡recuerde cambiar el parámetro "meanlog" por el valor que identificó anteriormente!)
library(MASS)
library(fitdistrplus)
fitdistr(hatch_perfem,"log-normal")
hatch_5_years=hatch_perfem/5
fitdistr(hatch_5_years,"log-normal")
data=rlnorm(1000, -0.92822498, 0.38756090)
exp(data)  # USe exp to convert he values from lognotmal to numbers again.
#c=log(2)
#exp(c)
beta_mom <- function(x) {
m_x <- mean(x, na.rm = TRUE)
s_x <- sd(x, na.rm = TRUE)
alpha <- m_x*((m_x*(1 - m_x)/s_x^2) - 1)
beta <- (1 - m_x)*((m_x*(1 - m_x)/s_x^2) - 1)
return(list(alpha = alpha, beta = beta))
}
library(fitdistrplus)
fit=fitdist(Larva_supevivencia,"beta")
Larva_supevivencia=c(0.184, 0.113, 0.355, 0.344, 0.295, 0.226, 0.207, 0.178, 0.171, 0.257)
beta_mom(Larva_supevivencia)
library(fitdistrplus)
fit=fitdist(Larva_supevivencia,"beta")
fit
plot(fit, las=1)
plot(fit, las=1)
Larva_supevivencia=c(0.184, 0.113, 0.355, 0.344, 0.295, 0.226, 0.207, 0.178, 0.171, 0.257)
beta_mom(Larva_supevivencia)
################
# Random number generation!
### Binomial random number generator
rbinom(1,size=10,prob=0.5)    # note: "size" is the number of coin flips, and "prob" is the probability of coming up 'heads'
### Poisson random number generator
rpois(1,lambda=4.1)     # note: "lambda" represents the mean (and variance!) of the Poisson distribution
### Uniform random number generator
runif(1,min=1,max=3.5)   # "min" and "max" are pretty obvious!
### Normal random number generator
rnorm(1,mean=3,sd=4.1)   # normal distribution is defined by "mean" and "sd" (standard deviation).
### lognormal random number generator (like normal distribution, but can not go below zero)
rlnorm(1,meanlog=0.5,sdlog=0.2)    # lognormal distribution is defined by "meanlog", the mean on the log scale and "sdlog" (standard deviation on the log scale).
### beta random number generator (bounded between 0 and 1- just like survival rate!)
rbeta(1,shape1=10,shape2=3)  # beta distribution is defined by "shape1" and "shape2", which together define the mean and spread within the range from 0 to 1.
## Para información sobr ela distribución beta vea los sigyuientes enlaces
# 1. https://keisan.casio.com/exec/system/1180573226
# 2. https://stats.stackexchange.com/questions/376634/how-to-pick-starting-parameters-for-massfitdist-with-the-beta-distribution
rbinom(1,size=10,prob=0.5)
### Binomial random number generator
rbinom(1,size=2,prob=0.5)    # note: "size" is the number of coin flips, and "prob" is the probability of coming up 'heads'
install.packages("mra")
install.packages("marked")
install.packages(c("BWStest", "markdown", "reactR", "svglite"))
install.packages("TMB")
install.packages("TMB", dependencies = TRUE)
