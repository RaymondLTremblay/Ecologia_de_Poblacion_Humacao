####
# Catastrophe
####
Flood_prob <- 0.0     # 0% chance of major flood
Flood_lambda <- 0.25    # 25% of population can survive a flood, should it occur!
## Set up data structures to store simulation results!
PVAdemo <- function(nreps,nyears,Init_N,R_max,K,Flood_prob,Flood_lambda){
#browser()
PopArray2 <- array(0,dim=c((nyears+1),nreps))
## start looping through replicates
for(rep in 1:nreps){
# set initial abundance
PopArray2[1,rep] <- Init_N     # initial abundance
### loop through years
for(y in 2:(nyears+1)){
### stochasticity and d-d
nextyear <- max(0,trunc(Ricker(PopArray2[y-1,rep])))
### catastrophe
if(runif(1)<Flood_prob) nextyear <- nextyear*Flood_lambda
PopArray2[y,rep] <- nextyear
}
}
return(PopArray2)
}
### Run the PVA!
Default <- PVAdemo(nreps,nyears,Init_N,R_max,K,Flood_prob,Flood_lambda)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
############################################################
####                                                    ####
####  NRES 470, Lecture 12                               ####
####                                                    ####
####  Kevin Shoemaker                                   ####
####  University of Nevada, Reno                        ####
####                                                    ####
############################################################
############################################################
####  Population Viability Analysis                     ####
############################################################
##############
# Demonstration PVA
##############
####
# Basic life history parameters
####
R_max <- 1.15       # Maximum rate of growth
Init_N <- 51        # Initial abundance
K <- 175            # Carrying capacity
####
# Environmental stochasticity
####
SD_lambda <- 0.11  # standard deviation of lambda
####
# Density-dependence (Ricker model)
####
Ricker <- function(prev_abund){       # this is a function for computing next-year abundance -- includes env stochasticity
prev_abund * exp(log(rnorm(1,R_max,SD_lambda))*(1-(prev_abund/K)))
}
####
# Catastrophe
####
Flood_prob <- 0.05     # 5% chance of major flood
Flood_lambda <- 0.25    # 25% of population can survive a flood
####
# Basic simulation parameters
####
nyears <- 100     # number of years
nreps <- 500      # number of replicates
PVAdemo <- function(nreps,nyears,Init_N,R_max,K,Flood_prob,Flood_lambda){
#browser()
PopArray2 <- array(0,dim=c((nyears+1),nreps))
## start looping through replicates
for(rep in 1:nreps){
# set initial abundance
PopArray2[1,rep] <- Init_N     # initial abundance
### loop through years
for(y in 2:(nyears+1)){
### stochasticity and d-d
nextyear <- max(0,trunc(Ricker(PopArray2[y-1,rep])))
### catastrophe
if(runif(1)<Flood_prob) nextyear <- nextyear*Flood_lambda
PopArray2[y,rep] <- nextyear
}
}
return(PopArray2)
}
### Run the PVA!
Default <- PVAdemo(nreps,nyears,Init_N,R_max,K,Flood_prob,Flood_lambda)
PlotCloud <- function(simdata){
plot(c(1:101),simdata[,1],col=gray(0.7),type="l",ylim=c(0,max(simdata)),xlab="Years",ylab="Abundance")
for(r in 2:ncol(simdata)){
lines(c(1:101),simdata[,r],col=gray(0.7),type="l")
}
}
PlotCloud(Default)
Extinction_byyear <- function(simdata){
apply(simdata,1,function(t)  length(which(t==0)))/ncol(simdata)
}
plot(c(1:101),Extinction_byyear(Default),type="l",lwd=2,xlab="year",ylab="extinction risk")
abline(h=0.05,col="red",lwd=2)
hist(Default[nrow(Default),],xlab="Final abundance after 100 years",ylab="Number of replicates",main="")
abline(v=Init_N,col="green",lwd=2)
declines <- seq(0,100,by=1)
declineprob <- numeric(length(declines))
for(s in 1:length(declines)){
declineprob[s] <- length(which(Default[nrow(Default),]<(Init_N-(declines[s]/100)*Init_N)))/ncol(Default)
}
plot(declines,declineprob,type="l",lwd=2,xlab="Decline threshold (percent)",ylab="Probability of falling below threshold")
abline(v=25,col="red",lwd=2)
Exctinction_risk <- function(simdata){
length(which(simdata[nrow(simdata),]==0))/ncol(simdata)
}
flood_lambdas <- seq(0.9,0.1,by=-0.05)
all_scenarios <- numeric(length(flood_lambdas))
for(scenario in 1:length(flood_lambdas)){
PVA <- PVAdemo(nreps,nyears,Init_N,R_max,K,Flood_prob,flood_lambdas[scenario])
all_scenarios[scenario] <- Exctinction_risk(PVA)
}
plot(flood_lambdas,all_scenarios,type="p",cex=2,xlab="flood impact (lambda in flood year)",ylab="extinction risk")
abline(h=0.05,col="red",lwd=2)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
Abundance_year0 <- c(2000,500,300,300,20)   # vector of initial abundances
Abundance_year0
rmd2rscript <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript_labanswers <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- c("answer","test")
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- grepl(input, pattern = stringToFind2[1], perl = TRUE) | grepl(input, pattern = stringToFind2[2])
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript("LECTURE12.Rmd")
.9^3
1-.9^3
0.5^3
1-0.5^3
0.5^3
1-0.5^3
(1-0.5^3)^2
(1-0.5^3)^3
(1-0.5^3)^3
(1-0.5^3)^5
0.9^5
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
##########
# OPEN POPULATION MODELS
##########
library(mra)   # remember to install the 'mra' package if you haven't already done this
install.packages(c("mra", "marked"))
##########
# OPEN POPULATION MODELS
##########
library(mra)   # remember to install the 'mra' package if you haven't already done this
data(dipper.histories)         # load up the data
head(dipper.histories,15)     # look at the top few lines
data(dipper.males)   # load up only the capture histories for male dippers!
##########
# OPEN POPULATION MODELS
##########
library(mra)   # remember to install the 'mra' package if you haven't already done this
data(dipper.histories)         # load up the data
head(dipper.histories,15)     # look at the top few lines
data(dipper.males)   # load up only the capture histories for male dippers!
library(marked)
data(dipper)
head(dipper)
read.table(ed_males.txt,sep="",header=F)
read.table('ed_males.txt',sep="",header=F)
head(read.table('ed_males.txt',sep="",header=F),15)
dpr <- read.table('ed_males.txt',sep="",header=F)
library(marked)
data(dipper)
dpr <- read.table('ed_males.txt',sep="",header=F)
names(dpr) <- c("ch","group")
head(dpr,15)
library(marked)    # remember to install the 'marked' package if you haven't already done this
?crm  # to get help on the main parameter estimation function in "marked"
##########
# load data!
data(dipper)
dipper.male <- dipper[which(dipper$sex=="Male"),]   # extract only the males, to compare with the Mark example
#############
# Process data
dipper.proc=process.data(dipper.male,model="cjs",begin.time=1)  # Helper function- process the data for CJS model
dipper.ddl=make.design.data(dipper.proc)    # another helper function- process data!
mod.Phit.pt <- crm(dipper.proc,dipper.ddl,model.parameters=list(Phi=list(formula=~time),p=list(formula=~time)))
cjs.hessian(mod.Phit.pt)
mod.Phit.pt
mod.Phit.pt$results$AIC
?crm
?optimx
mod.Phit.pt <- crm(dipper.proc,dipper.ddl,model.parameters=list(Phi=list(formula=~time),p=list(formula=~time)),method="Nelder-Mead")
mod.Phit.pt
mod.Phit.pt$results$AIC
mod.Phit.pt$results$AIC
cjs.hessian(mod.Phit.pt)
mod.Phidot.pdot <- crm(dipper.proc,dipper.ddl,model.parameters = list(Phi=list(formula=~1),p=list(formula=~1)),method="Nelder-Mead")
cjs.hessian(mod.Phidot.pdot)
cjs.hessian(mod.Phit.pt)
mod.Phit.pt <- crm(dipper.proc,dipper.ddl,model.parameters=list(Phi=list(formula=~time),p=list(formula=~time)),method="Nelder-Mead")
cjs.hessian(mod.Phit.pt)
mod.Phit.pt   # print out model
mod.Phit.pt   # print out model
mod.Phit.pt <- crm(dipper.proc,dipper.ddl,model.parameters=list(Phi=list(formula=~time),p=list(formula=~time)),method="Nelder-Mead",hessian = T)
mod.Phit.pt   # print out model
mod.Phit.pt$results$AIC       # extract AIC
mod.Phidot.pdot <- crm(dipper.proc,dipper.ddl,model.parameters = list(Phi=list(formula=~1),p=list(formula=~1)),method="Nelder-Mead",hessian = TRUE)
cjs.hessian(mod.Phidot.pdot)
cjs.hessian(mod.Phidot.pdot)
mod.Phidot.pdot$results$AIC
allmodels <- crm.wrapper(cml,data=dipper.proc, ddl=dipper.ddl,external=FALSE,accumulate=FALSE,method="Nelder-Mead",hessian=TRUE)
Phi.dot <- list(formula=~1)
Phi.time <- list(formula=~time)
p.dot <- list(formula=~1)
p.time <- list(formula=~time)
cml=create.model.list(c("Phi","p"))    # create list of all models to run
allmodels <- crm.wrapper(cml,data=dipper.proc, ddl=dipper.ddl,external=FALSE,accumulate=FALSE,method="Nelder-Mead",hessian=TRUE)
allmodels
allmodels
allmodels[[1]]
library(help="marked")
vignette("markedVignette","marked")
predict.crm
predict(allmodels[[1]])
predict(allmodels[[1]])
predict(allmodels[[2]])
predict(allmodels[[2]])
predict(allmodels[[2]])$Phi
predict(allmodels[[3]])$Phi
predict(allmodels[[1]])#Phi
predict(allmodels[[1]])$Phi
Phi_by_year <- predict(allmodels[[3]])$Phi    # predict Phi
##########
# OPEN POPULATION MODELS
##########
library(marked)    # remember to install the 'marked' package if you haven't already done this
?crm  # to get help on the main parameter estimation function in "marked"
# library(help="marked")
vignette("markedVignette","marked")
##########
# load data!
data(dipper)
dipper.male <- dipper[which(dipper$sex=="Male"),]   # extract only the males, to compare with the Mark example
#############
# Process data
dipper.proc=process.data(dipper.male,model="cjs",begin.time=1)  # Helper function- process the data for CJS model
dipper.ddl=make.design.data(dipper.proc)    # another helper function- process data!
##########
# Fit models
########
# fit time-varying cjs model
mod.Phit.pt <- crm(dipper.proc,dipper.ddl,model.parameters=list(Phi=list(formula=~time),p=list(formula=~time)),method="Nelder-Mead",hessian = T)
mod.Phit.pt   # print out model
mod.Phit.pt$results$AIC       # extract AIC
########
# fit time-invariant cjs model
mod.Phidot.pdot <- crm(dipper.proc,dipper.ddl,model.parameters = list(Phi=list(formula=~1),p=list(formula=~1)),method="Nelder-Mead",hessian = TRUE)
mod.Phidot.pdot
mod.Phidot.pdot$results$AIC
###########
# compare all models with AIC
###########
######
# Set up models to run (must have either "Phi." or "p." in the name)
Phi.dot <- list(formula=~1)
Phi.time <- list(formula=~time)
p.dot <- list(formula=~1)
p.time <- list(formula=~time)
cml=create.model.list(c("Phi","p"))    # create list of all models to run
######
# Run all models
allmodels <- crm.wrapper(cml,data=dipper.proc, ddl=dipper.ddl,external=FALSE,accumulate=FALSE,method="Nelder-Mead",hessian=TRUE)
allmodels
#######
# get parameter estimates and confidence intervals for best model
allmodels[[1]]
#######
# make predictions and plot them.
predict(allmodels[[1]])$Phi
Phi_by_year <- predict(allmodels[[3]])$Phi    # predict Phi for all years (based on the best Phi(t) model)
plot(1:7,Phi_by_year$estimate,xlab="Year",ylab="Survival")
plot(1:nrow(Phi_by_year),Phi_by_year$estimate,xlab="Year",ylab="Survival")
plot(1:nrow(Phi_by_year),Phi_by_year$estimate,xlab="Year",ylab="Survival",ylim=c(0,1))
library(Hmisc)
library(Hmisc)   #load Hmisc package- has a nice error bar function
plot(1:nrow(Phi_by_year),Phi_by_year$estimate,xlab="Year",ylab="Survival",ylim=c(0,1))
errbar(1:nrow(Phi_by_year),Phi_by_year$estimate,Phi_by_year$ucl,Phi_by_year$lcl,add=T)
##########
# OPEN POPULATION MODELS
##########
library(marked)    # remember to install the 'marked' package if you haven't already done this
?crm  # to get help on the main parameter estimation function in "marked"
# library(help="marked")
vignette("markedVignette","marked")
##########
# load data!
data(dipper)
dipper.male <- dipper[which(dipper$sex=="Male"),]   # extract only the males, to compare with the Mark example
#############
# Process data
dipper.proc=process.data(dipper.male,model="cjs",begin.time=1)  # Helper function- process the data for CJS model
dipper.ddl=make.design.data(dipper.proc)    # another helper function- process data!
##########
# Fit models
########
# fit time-varying cjs model
mod.Phit.pt <- crm(dipper.proc,dipper.ddl,model.parameters=list(Phi=list(formula=~time),p=list(formula=~time)),method="Nelder-Mead",hessian = T)
mod.Phit.pt   # print out model
mod.Phit.pt$results$AIC       # extract AIC
########
# fit time-invariant cjs model
mod.Phidot.pdot <- crm(dipper.proc,dipper.ddl,model.parameters = list(Phi=list(formula=~1),p=list(formula=~1)),method="Nelder-Mead",hessian = TRUE)
mod.Phidot.pdot
mod.Phidot.pdot$results$AIC
###########
# compare all models with AIC
###########
######
# Set up models to run (must have either "Phi." or "p." in the name)
Phi.dot <- list(formula=~1)
Phi.time <- list(formula=~time)
p.dot <- list(formula=~1)
p.time <- list(formula=~time)
cml=create.model.list(c("Phi","p"))    # create list of all models to run
######
# Run all models
allmodels <- crm.wrapper(cml,data=dipper.proc, ddl=dipper.ddl,external=FALSE,accumulate=FALSE,method="Nelder-Mead",hessian=TRUE)
allmodels
#######
# get parameter estimates and confidence intervals for best model
allmodels[[1]]
#######
# make predictions and plot them.
predict(allmodels[[1]])$Phi
Phi_by_year <- predict(allmodels[[3]])$Phi    # predict Phi for all years (based on the best Phi(t) model)
library(Hmisc)   #load Hmisc package- has a nice error bar function
plot(1:nrow(Phi_by_year),Phi_by_year$estimate,xlab="Year",ylab="Survival",ylim=c(0,1),main="Variability in Survival, dipper demo")
errbar(1:nrow(Phi_by_year),Phi_by_year$estimate,Phi_by_year$ucl,Phi_by_year$lcl,add=T)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmd2rscript <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript_labanswers <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- c("answer","test")
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- grepl(input, pattern = stringToFind2[1], perl = TRUE) | grepl(input, pattern = stringToFind2[2])
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript("LAB7.Rmd")
rmd2rscript("LECTURE15.Rmd")
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
###########
# Cormack-Jolly-Seber (CJS) model in R
###########
library(marked)      # install the 'marked' package if you haven't already done this!
data("dipper")
head(dipper,10)
data(dipper)      # load data
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
data(dipper)      # load data
library(marked)      # install the 'marked' package if you haven't already done this!
data("dipper")
>cra
?cra
?mra
data(dipper)
dipper.proc=process.data(dipper,model="cjs",begin.time=1)  # Helper function- process the data for CJS model
dipper.ddl=make.design.data(dipper.proc)    # another helper function- process data!
data(dipper)
dipper.proc=process.data(dipper,model="cjs",begin.time=1)  # Helper function- process the data for CJS model
dipper.ddl=make.design.data(dipper.proc)    # another helper function- process data!
dipper.ddl
dipper.ddl$Phi
dipper.proc$data
dipper.proc$model
dipper.proc$mixtures
dipper.proc$freq
dipper.proc=process.data(dipper,model="cjs",begin.time=1)  # Helper function- process the data for CJS model
dipper.ddl=make.design.data(dipper.proc)    # another helper function- process data!
mod.Phit.pt <- crm(dipper.proc,dipper.ddl,model.parameters=list(Phi=list(formula=~time),p=list(formula=~time)),method="Nelder-Mead",hessian = T)
mod.Phit.pt   # print out model
mod.Phit.pt   # print out model
mod.Phidot.pdot <- crm(dipper.proc,dipper.ddl,model.parameters = list(Phi=list(formula=~1),p=list(formula=~1)),method="Nelder-Mead",hessian = TRUE)
dipper
head(dipper_
head(dipper)
mod.Phidot.pdot <- crm(dipper.proc,dipper.ddl,model.parameters = list(Phi=list(formula=~sex),p=list(formula=~sex)),method="Nelder-Mead",hessian = TRUE)
mod.Phidot.pdot <- crm(dipper.proc,dipper.ddl,model.parameters = list(Phi=list(formula=~1),p=list(formula=~1)),method="Nelder-Mead",hessian = TRUE)
mod.Phidot.pdot
mod.Phisex.psex <- crm(dipper.proc,dipper.ddl,model.parameters = list(Phi=list(formula=~sex),p=list(formula=~sex)),method="Nelder-Mead",hessian = TRUE)
mod.Phisex.psex
mod.Phisex.psex$results$AIC
Phi.dot <- list(formula=~1)
Phi.time <- list(formula=~time)
Phi.sex <- list(formula=~sex)
Phi.timesex <- list(formula=~sex+time)
p.dot <- list(formula=~1)
p.time <- list(formula=~time)
p.sex <- list(formula=~sex)
p.timesex <- list(formula=~sex+time)
cml=create.model.list(c("Phi","p"))    # create list of all models to run
allmodels <- crm.wrapper(cml,data=dipper.proc, ddl=dipper.ddl,external=FALSE,accumulate=FALSE,method="Nelder-Mead",hessian=TRUE)
allmodels
allmodels
allmodels[[1]]
p.timesex2 <- list(formula=~sex*time)
cml=create.model.list(c("Phi","p"))    # create list of all models to run
allmodels <- crm.wrapper(cml,data=dipper.proc, ddl=dipper.ddl,external=FALSE,accumulate=FALSE,method="Nelder-Mead",hessian=TRUE)
p.timesex2 <- list(formula=~sex*time)
allmodels
allmodels[[6]]
allmodels[[6]]
allmodels[[11]]
allmodels[[11]]
Phi_by_year <- predict(allmodels[[11]])$Phi    # predict Phi for all years (based on the best Phi(t) model)
Phi_by_year
Phi_by_year
library(Hmisc)   #load Hmisc package- has a nice error bar function
errbar(1:nrow(Phi_by_year),Phi_by_year$estimate,Phi_by_year$ucl,Phi_by_year$lcl,add=T)
library(Hmisc)   #load Hmisc package- has a nice error bar function
plot(1:nrow(Phi_by_year),Phi_by_year$estimate,xlab="Year",ylab="Survival",ylim=c(0,1),main="Variability in Survival, dipper demo")
errbar(1:nrow(Phi_by_year),Phi_by_year$estimate,Phi_by_year$ucl,Phi_by_year$lcl,add=T)
plot(1:nrow(Phi_by_year),Phi_by_year$estimate,xlab="Year",ylab="Survival",ylim=c(0,1),main="Variability in Survival, dipper demo")
plot(1:nrow(Phi_by_year),Phi_by_year$estimate,xlab="Year",ylab="Survival",ylim=c(0,1),main="Variability in Survival, dipper demo")
plot(1:nrow(Phi_by_year),Phi_by_year$estimate,xlab="Year",ylab="Survival",ylim=c(0,1),main="Variability in Survival, dipper demo")
errbar(1:nrow(Phi_by_year),Phi_by_year$estimate,Phi_by_year$ucl,Phi_by_year$lcl,add=T)
data(dipper)      # load data
ct <- as.factor( paste("T",1:ncol(dipper.histories), sep=""))      # specify which years were modeled
attr(ct,"nan")<-nrow(dipper.histories)  # assign the proper number of individuals
mean(Phi_by_year)
Phi_by_year
mean(Phi_by_year$estimate)
sd(Phi_by_year$estimate)
install.packages(c("meta", "metafor"))
