showcontours <- compiler::cmpfun(function(fun,xlims, ylims,resol=250,add=F, colors=c('red', 'blue'),parms=NULL) {
x <- matrix(seq(xlims[1],xlims[2], length=resol), byrow=F, resol,resol);
y <- matrix(seq(ylims[1],ylims[2], length=resol),byrow=T, resol, resol);
npts = resol*resol;
z <- fun(x,y,parms);
z1 <- matrix(z[1:npts], resol, resol);
z2 <- matrix(z[(npts+1):(2*npts)], resol, resol);
contour(x[,1],y[1,],z1, add=add, col=colors[1]);
contour(x[,1],y[1,],z2, add=T, col=colors[2]);
})
##  Split into nullclines.calc() and nullclines.draw()
nullclines <- compiler::cmpfun(function(fun,xlims, ylims, resol=250, add=F,parms=NULL) {
x <- matrix(seq(xlims[1],xlims[2], length=resol), byrow=F, resol,resol);
y <- matrix(seq(ylims[1],ylims[2], length=resol),byrow=T, resol, resol);
npts = resol*resol;
z <- fun(x,y,parms);
z1 <- matrix(z[1:npts], resol, resol);
z2 <- matrix(z[(npts+1):(2*npts)], resol, resol);
contour(x[,1],y[1,],z1,levels=c(0), drawlabels=F,add=add, col="orange");
contour(x[,1],y[1,],z2,levels=c(0), drawlabels=F,add=T, col="magenta");
title(main="Orange = x nullcline, Magenta = y nullcline",cex=0.35);
})
nullclines.data <- list()
nullclines.calc <- compiler::cmpfun(function(fun,xlims,ylims,resol=250,parms=NULL) {
x <- matrix(seq(xlims[1],xlims[2], length=resol), byrow=F, resol,resol);
y <- matrix(seq(ylims[1],ylims[2], length=resol),byrow=T, resol, resol);
npts = resol*resol;
z <- fun(x,y,parms);
z1 <- matrix(z[1:npts], resol, resol);
z2 <- matrix(z[(npts+1):(2*npts)], resol, resol);
return(list(x,y,z1,z2)) # return nullclines.data
})
nullclines.draw <- compiler::cmpfun(function(ndat=nullclines.data,add=T){
x <- ndat[[1]]
y <- ndat[[2]]
z1<- ndat[[3]]
z2<- ndat[[4]]
contour(x[,1],y[1,],z1,levels=c(0), drawlabels=F,add=add, col="orange");
contour(x[,1],y[1,],z2,levels=c(0), drawlabels=F,add=T, col="magenta");
#title(main="Orange = x nullcline, Magenta = y nullcline",cex=0.35);
})
## We need something like an array or list for each trajectory, that we can add to.
## BETA VERSION: Don't track time. Add that in later once it all works?
##
## 1. Structure to save curves: traj.data
traj.data=list() # each element will be an Mx3 matrix like cbind(time,x,y)
## 2. Function to plot them all. Allow ability to pass args to ode() via ...
traj.draw = function(tdat=traj.data,col="blue",lwd=2) {
#print(unlist(tdat[[1]]))
for(i in 1:length(tdat)) {
lines(tdat[[i]][,2:3], lwd=lwd, col=col)}
}
## 3. grid.calc()
grid.calc <- compiler::cmpfun(function(fun,xlim,ylim,parms,ngrid,maxtime=50) {
xvals=seq(xlim[1],xlim[2],length=ngrid);
yvals=seq(ylim[1],ylim[2],length=ngrid);
ts <- list()
for(i in 1:ngrid) {
for(j in 1:ngrid) {
out1=ode(times=  seq(0,maxtime,length=500),y=c(xvals[i],yvals[j]),func=as.ode.func(fun),parms=parms);
out2=ode(times= -seq(0,maxtime,length=500),y=c(xvals[i],yvals[j]),func=as.ode.func(fun),parms=parms);
ts[[length(ts)+1]] <- rbind(out2[nrow(out2):2 , ],out1)
}}
return(ts)
})
## 4. traj.forward() and traj.backward()
traj.forward  = compiler::cmpfun(function(x0,fun,parms,maxtime,Tlen=500,...){
out=ode(times=seq(0,maxtime,length=Tlen),y=c(x0[1],x0[2]),func=as.ode.func(fun),parms=parms,...);
return(out);
})
traj.backward = compiler::cmpfun(function(x0,fun,parms,maxtime,Tlen=500,...){
out=ode(times=seq(0,-maxtime,length=Tlen),y=c(x0[1],x0[2]),func=as.ode.func(fun),parms=parms,...);
return(out[nrow(out):1,]);
})
## 5. traj.continue()
traj.continue <- compiler::cmpfun(function(fun, parms, tdat, maxtime, Tlen=500, backward=FALSE, ...){
if(length(tdat)==0) { cat("WARNING: No trajectories have been calculate yet!\n")}
out.curr <- tdat[[length(tdat)]]
if(backward) {
X0=head(out.curr,1);
t0=X0[1];
x0=X0[-1];
times=t0+seq(0,-maxtime,length=Tlen);
out=ode(times=times,y=x0,func=as.ode.func(fun),parms=parms,...);
return(rbind(out[nrow(out):2,],out.curr));
} else {
X0=tail(out.curr,1);
t0=X0[1]
x0=X0[-1]
times=t0+seq(0,maxtime,length=Tlen);
out=ode(times=times,y=x0,func=as.ode.func(fun),parms=parms,...);
return(rbind(out.curr,out[-1,]));
}
})
## original grid() function
grid=compiler::cmpfun(function(fun,xlim,ylim,parms,ngrid,maxtime=50,Tlen=500,add=F,color="blue") {
if (add==F) {
plot(1,xlim=xlim, ylim=ylim, type='n',xlab="x",ylab="y");
}
xvals=seq(xlim[1],xlim[2],length=ngrid);
yvals=seq(ylim[1],ylim[2],length=ngrid);
for(i in 1:ngrid) {
for(j in 1:ngrid) {
out=ode(times=seq(0,maxtime,length=Tlen),y=c(xvals[i],yvals[j]),func=as.ode.func(fun),parms=parms);
points(out[,2],out[,3],type="l",lwd=2,col=color);
out=ode(times=-seq(0,maxtime,length=Tlen),y=c(xvals[i],yvals[j]),func=as.ode.func(fun),parms=parms);
points(out[,2],out[,3],type="l",lwd=2,col=color);
}}
})
# Newton's method to find equilibria of vector field.
# func() must have the same input arguments and returns as for ode/rk4.
# Inputs:
#   x0 = intial guess at equilibrium. If x0 is not supplied in the call,
#        the user chooses it from the current graphics device via locator()
#         and the equilibrium is plotted to the same device. Plotting
#         symbol is closed/open=stable/unstable, circle/triangle=eigenvalues imaginary/real.
#   tol= Convergence tolerance
#   niter = Maximum number of iterations
#   inc = finite-difference increment for derivative estimates
# Coded 5/25/06 by SPE based on Matlab toggle.m by JG
# MODIFIED 7/2016 by PJH to take functions fun(x,y,parms)
newton=compiler::cmpfun(function(fun,x0=NULL,parms=NULL,tol=1e-16,niter=40,inc=1e-6,plotit=TRUE) {
x=x0; #initial x
if (is.null(x0)) {
warning("Oops! newton() was called without x0 specified!");#{x = locator(n=1); x=c(x$x,x$y)};
return(list(x=c(NA,NA,df=matrix(NA,2,2),pch=NA)))
}
nx = length(x); # length of state vector
######### Newton iteration loop: start
for(i in 1:niter){
y = as.ode.func(fun)(0,x,parms)[[1]]
df = matrix(0,nx,nx); # Compute df
for(j in 1:nx) {
#Increment vector for estimating derivative wrt jth coordinate
v=rep(0,nx);
v[j] = inc;
df[,j]=  (as.ode.func(fun)(t,x+v,parms)[[1]] - as.ode.func(fun)(t,x-v,parms)[[1]])/(2*inc)
}
if (sum(y^2) < tol){  #check for convergence
if(plotit){
ev=eigen(df)$values; pch1=1+as.numeric(Im(ev[1])!=0); pch2=1+as.numeric(max(Re(ev))<0);
pchs=matrix( c(2,17,1,16),2,2,byrow=T);
#points(x[1],x[2],type="p",pch=pchs[pch1,pch2],cex=1.5)
}
cat("Fixed point (x,y) = ",x,"\n");
cat("Jacobian Df=","\n"); print(df);cat("Eigenvalues","\n"); print(eigen(df)$values)
return(list(x=x,df=df,pch=pchs[pch1,pch2]))
} # end convergence check
x = x - solve(df,y) # one more step if needed
cat(i, x, "\n") #print out the next iterate
}
######### Newton iteration loop: end
cat("Convergence failed");
})
## to draw fixed points
fixed.points.draw <- compiler::cmpfun(function(FPs) {
for(i in 1:length(FPs)) { points(FPs[[i]]$x[1], FPs[[i]]$x[2], cex=1.5, type="p",pch=FPs[[i]]$pch)}
})
manifolds.calc <- compiler::cmpfun(function(fun,parms,FPs,maxtime=250, Tlen=500) {
ms = list()
for(i in 1:length(FPs)) { if(!any(is.na(FPs[[i]]$x))) {
x=FPs[[i]]$x; df=FPs[[i]]$df; V=eigen(df)$vectors; ev=eigen(df)$values;
if (sign(Re(ev[1])) != -sign(Re(ev[2])) | Im(ev[1]) != 0) {
# if not a saddle...
ms[[i]] <- list(S=matrix(NA,nrow=1,ncol=2),U=matrix(NA,nrow=1,ncol=2))
}else{
i1=which(Re(ev)>0); i2=which(Re(ev)<0);
v1=V[,i1]; v2=V[,i2]; eps=1e-3;
out1=ode(y=x+eps*v1,times=seq(0,maxtime,length=Tlen),func=as.ode.func(fun),parms=parms);
out2=ode(y=x-eps*v1,times=seq(0,maxtime,length=Tlen),func=as.ode.func(fun),parms=parms);
out3=ode(y=x+eps*v2,times=-seq(0,maxtime,length=Tlen),func=as.ode.func(fun),parms=parms);
out4=ode(y=x-eps*v2,times=-seq(0,maxtime,length=Tlen),func=as.ode.func(fun),parms=parms);
S = rbind(out3,out4[1,]*NA,out4)[,-1]
U = rbind(out1,out2[1,]*NA,out2)[,-1]
ms[[i]] <- list(S=S,U=U)
}} else { # if x[1] is NA...
ms[[i]] <- list(S=matrix(NA,nrow=1,ncol=2),U=matrix(NA,nrow=1,ncol=2))
}
}
return(ms)
})
manifolds.draw=compiler::cmpfun(function(ms) {
for(i in 1:length(ms)){
S=ms[[i]]$S
U=ms[[i]]$U
title(sub="Black=stable manifold, Red=unstable manifold");
points(S[,1],S[,2],type="l",lwd=2,col="black");
points(U[,1],U[,2],type="l",lwd=2,col="red");
}
})
# Compute Jacobian of a planar vector field at a point (x,y),
# either input or chosen with locator().
jacobianAtXY <- compiler::cmpfun(function(fun,x=NULL, y=NULL,inc=1e-7){
if (is.null(x)|is.null(y)) {
x0 <- locator(n=1); x <- x0$x; y <- x0$y;
}
foo <- fun(x,y); h = inc;
foox <- fun(x+h,y); fooy <- fun(x,y+h);
A <- (foox[1] - foo[1])/h;
B <- (fooy[1] - foo[1])/h;
C <- (foox[2] - foo[2])/h;
D <- (fooy[2] - foo[2])/h;
return(matrix( c(A,B,C,D ),2,2,byrow=T))
})
##########
# Â¡Visualice el plano de fase con flechas!
##########
#######################################################################################
## SPECIFY MODEL AND INITIALIZE
#
## toggle switch function for phase arrow and nullcline plotting
toggle = compiler::cmpfun(function(u,v,parms) {
c( u*parms[1]*(1-(u+(parms[2]*v))/parms[3]), v*parms[4]*(1-(v+(parms[5]*u))/parms[6]) )
})
fun=toggle ## Our generic name for the system of equations to look at! ;-)
#
## toggle switch function for computing solution trajectories with deSolve::ode()
#Toggle = as.ode.func(toggle)
#
## parameter values?
Rmax1 <- 0.05
Alpha <- 0.3
K1 <- 1000
Rmax2 <- 0.3
Beta <- 0.2
K2 <- 450
parms=c(Rmax1,Alpha,K1,Rmax2,Beta,K2)
# toggle(100,100,parms)
xlim = c(5,2000)
ylim = c(5,1000)
new <- phasearrows.calc(toggle,xlim,ylim,resol=25,parms=parms)
plot(1,1,pch="",xlim=xlim,ylim=ylim,xlab="N1",ylab="N2")
phasearrows.draw(new)
#
## END MODEL SPECIFICATION AND INITIALIZATION
#######################################################################################
#### example with phase-plane arrows
plot(1,1,pch="",xlim=xlim,ylim=ylim,xlab="N1",ylab="N2")
phasearrows.draw(new)
abline(K1/Alpha,-(K1/Alpha)/K1,col="red",lwd=3)   # species 1
abline(K2,-K2/(K2/Beta),col="blue",lwd=3)   # species 1
##########
# Another example
##########
Rmax1 <- 0.2
Alpha <- 1.1
K1 <- 1000
Rmax2 <- 0.2
Beta <- 0.9
K2 <- 500
parms=c(Rmax1,Alpha,K1,Rmax2,Beta,K2)
# toggle(100,100,parms)
xlim = c(5,1500)
ylim = c(5,1000)
new <- phasearrows.calc(toggle,xlim,ylim,resol=25,parms=parms)
plot(1,1,pch="",xlim=xlim,ylim=ylim,xlab="N1",ylab="N2")
phasearrows.draw(new)
abline(K1/Alpha,-(K1/Alpha)/K1,col="red",lwd=3)   # species 1
abline(K2,-K2/(K2/Beta),col="blue",lwd=3)   # species 2
#########
# And another example!
#########
Rmax1 <- 0.5
Alpha <- 1.05
K1 <- 890
Rmax2 <- 0.2
Beta <- 0.5
K2 <- 890
parms=c(Rmax1,Alpha,K1,Rmax2,Beta,K2)
# toggle(100,100,parms)
xlim = c(5,1500)
ylim = c(5,1000)
new <- phasearrows.calc(toggle,xlim,ylim,resol=25,parms=parms)
plot(1,1,pch="",xlim=xlim,ylim=ylim,xlab="N1",ylab="N2")
phasearrows.draw(new)
abline(K1/Alpha,-(K1/Alpha)/K1,col="red",lwd=3)   # species 1
abline(K2,-K2/(K2/Beta),col="blue",lwd=3)   # species 2
########
# And another!
#########
Alpha <- 0.3
Beta <- 0.2
K1 <- 1000
K2 <- 450
Rmax1 <- 0.05
Rmax2 <- 0.3
Nyears <- 1000
ylim=c(0,K2*1.5)
xlim=c(0,K1*1.5)
plot(1,1,pch="",ylim=ylim,xlim=xlim,xlab="species 1",ylab="species 2")
points(jitter(System[,1],500),jitter(System[,2],500),col="brown",pch=20,cex=0.4)
points(jitter(System1[,1],500),jitter(System1[,2],500),col="green",pch=20,cex=0.4)
points(jitter(System2[,1],500),jitter(System2[,2],500),col="red",pch=20,cex=0.4)
points(jitter(System3[,1],500),jitter(System3[,2],500),col="blue",pch=20,cex=0.4)
parms=c(Rmax1,Alpha,K1,Rmax2,Beta,K2)
xlim = c(5,1500)
ylim = c(5,1000)
new <- phasearrows.calc(toggle,xlim,ylim,resol=15,parms=parms)
phasearrows.draw(new)
abline(h=K2,v=K1,col="gray",lwd=2,lty=2)
abline(K1/Alpha,-(K1/Alpha)/K1,col="red",lwd=2)   # species 1
abline(K2,-K2/(K2/Beta),col="blue",lwd=2)   # species 2
########
# And finally...
########
Rmax1 <- 0.2
Alpha <- 1.5
K1 <- 1000
Rmax2 <- 0.2
Beta <- 2
K2 <- 1500
parms=c(Rmax1,Alpha,K1,Rmax2,Beta,K2)
# toggle(100,100,parms)
xlim = c(5,1500)
ylim = c(5,1000)
new <- phasearrows.calc(toggle,xlim,ylim,resol=25,parms=parms)
plot(1,1,pch="",xlim=xlim,ylim=ylim,xlab="N1",ylab="N2")
phasearrows.draw(new)
abline(K1/Alpha,-(K1/Alpha)/K1,col="red",lwd=3)   # species 1
abline(K2,-K2/(K2/Beta),col="blue",lwd=3)   # species 2
install.packages("mra")
install.packages("popbio")
install.packages("TMB")
install.packages("popdemo")
install.packages("Rcompadre")
install.packages("Rage")
install.packages("stagePop")
knitr::opts_chunk$set(echo = TRUE)
courseSchedule <- read.csv("CourseSchedule.csv")
courseSchedule
library(kableExtra)
kbl(courseSchedule,caption = "")
install.packages("kableExtra")
knitr::opts_chunk$set(echo = TRUE)
courseSchedule
install.packages("stagePop")
R.versoion
R.version
install.packages(c("clinfun", "cpp11", "datos", "dbplyr", "DEoptimR", "digest", "downlit", "ellipse", "fs", "gargle", "gmp", "haven", "igraph", "insight", "jsonlite", "KernSmooth", "lavaan", "lme4", "Matrix", "MatrixModels", "mc2d", "mgcv", "openssl", "pkgload", "PMCMRplus", "processx", "quantmod", "quantreg", "raster", "Rcpp", "readxl", "remotes", "Rfast", "Rfast2", "rgl", "rmarkdown", "rstudioapi", "sass", "sf", "shiny", "spatial", "spData", "testthat", "usethis", "V8", "viridis", "xml2"))
install.packages("stagePop")
install.packages("Rmarkdown", dependencies = TRUE)
install.packages("quarto", dependencies = TRUE)
install.packages(c("aplot", "bookdown", "bslib", "chromote", "cpp11", "curl", "DEoptimR", "effectsize", "gert", "ggfun", "ggplot2", "ggplotify", "gifski", "gss", "HistData", "htmltools", "igraph", "leaflet.providers", "Matrix", "modeldata", "nlme", "patchwork", "PearsonDS", "promises", "purrr", "RcppArmadillo", "Rfast2", "rgl", "rmarkdown", "Rmpfr", "rsconnect", "shiny", "survival", "tinytex", "units", "webshot2", "xfun", "yulab.utils"))
install.packages(c("rgl", "rsconnect"))
knitr::opts_chunk$set(echo = TRUE)
R3=matrix(c(
0.43, 	0,	  0,    0.14,
0.38,	0.84, 	0,	  0,
0, 	    0,	  0.51,	0.15,
0,      0.14, 0.43, 0.84
), byrow=TRUE, ncol=4)
Lrub1=R3
Lrub1
R3T=matrix(c(
0.43, 	0,	  0,    0.00,
0.38,	0.84, 	0,	  0,
0, 	    0,	  0.51,	0.15,
0,      0.14, 0.43, 0.84
), byrow=TRUE, ncol=4)
R3T
R3F=matrix(c(
0.0, 	0,	  0,    0.00,
0.0,	0, 	0,	  0,
0, 	  0,	  0,	0,
0,    0, 0, 0
), byrow=TRUE, ncol=4)
R3T+R3F
R3T+R3F
TF=R3T+R3F
TF
R3T=matrix(c(
0.43, 	0,	  0,    0.00,
0.38,	0.84, 	0,	  0,
0, 	    0,	  0.51,	0.15,
0,      0.14, 0.43, 0.84
), byrow=TRUE, ncol=4)
R3T
R3F=matrix(c(
0.0, 	0,	  0,    0.14,
0.0,	0, 	0,	  0,
0, 	  0,	  0,	0,
0,    0, 0, 0
), byrow=TRUE, ncol=4)
TF=R3T+R3F
TF
R3F
TF=R3T+R3F
TF
library(Rage)
library(Rage)
plot_life_cycle(Lrub1, stages=stages)
library(Rage)
stages <- c("plantulas", "juveniles", "adulto_no_reproductivos", "adultos_reproductivos")
plot_life_cycle(Lrub1, stages=stages)
isErgodic(Lrub1, digits=10, return.eigvec=FALSE)
library(popdemo)
library(popbio)
isErgodic(Lrub1, digits=10, return.eigvec=FALSE)
isIrreducible(Lrub1)
isErgodic(Lrub1, digits=10, return.eigvec=FALSE)
isIrreducible(Lrub1)
par(mar=c(10,4,1,1))
n0.amp <- c(1000,1,1,1)
n0.att <- c(1,1,1,1000)
pr2.1 <- project(Lrub1, vector=n0.amp, time=156,
standard.A=T, standard.vec=T)
pr2.2 <- project(Lrub1, vector=n0.att, time=156,
standard.A=T, standard.vec=T)
plot(pr2.1, ylim=c(0.4,1), log="y", cex.axis=0.8)
text(52, pr2.1[51], "amplification",
adj=c(1,-0.5), cex=0.8)
maxamp(Lrub1, vector=n0.amp)
n0.amp <- c(1000,1,1,1)
n0.att <- c(1,1,1,1000)
text(52, pr2.1[51], "amplification",
adj=c(1,-0.5), cex=0.8)
plot(pr2.1, ylim=c(0.4,1), log="y", cex.axis=0.8)
text(52, pr2.1[51], "amplification",
adj=c(1,-0.5), cex=0.8)
maxamp(Lrub1, vector=n0.amp)
plot(pr2.2, ylim=c(0.4,1), log="y", cex.axis=0.8)
text(52, pr2.2[51], "amplification",
adj=c(1,-0.5), cex=0.8)
maxamp(Lrub1, vector=n0.amp)
plot(pr2.1, ylim=c(0.4,1), log="y", cex.axis=0.8)
text(52, pr2.1[51], "amplification",
adj=c(1,-0.5), cex=0.8)
maxamp(Lrub1, vector=n0.att)
reactivity(Lrub1,vector=n0.att)
inertia(Lrub1,vector=n0.att)
pr1 <- project(Lrub1, vector=n0, time=24)
n0 <- c(0, 0, 2, 0)
pr1 <- project(Lrub1, vector=n0, time=24)
#Plot the projection. This uses an S3 plotting
#method for projections. For info, see '?plot.projection'.
plot(pr1)
n0 <- c(10, 10, 20, 10)
pr1 <- project(Lrub1, vector=n0, time=24)
#Plot the projection. This uses an S3 plotting
#method for projections. For info, see '?plot.projection'.
plot(pr1)
eigs <- eigen(Lrub1)
eigs
lambdamax <- Re(eigs$values[1])
lambdamax
w <- stable.stage(Lrub1)
w
pr2.2
pr2.1
n0.amp <- c(10000,1,1,1)
pr2.1 <- project(Lrub1, vector=n0.amp, time=156,
standard.A=T, standard.vec=T)
pr2.1
plot(pr2.1, ylim=c(0.4,1), log="y", cex.axis=0.8)
maxamp(Lrub1, vector=n0.amp)
reactivity(Lrub1,vector=n0.amp)
inertia(Lrub1,vector=n0.amp)
reactivity(Lrub1,vector=n0.amp)
reac(Lrub1,vector=n0.amp)
reac(Lrub1,vector=n0.amp, bound = "upper")
reac(Lrub1,bound = "upper")
inertia(Lrub1,bound = "lower")
plot(pr2.1, ylim=c(0.4,1), log="y", cex.axis=0.8)
text(52, pr2.1[51], "amplification",
adj=c(1,-0.5), cex=0.8)
maxamp(Lrub1, vector=n0.amp)
maxamp(Lrub1)
plot(pr2.1, ylim=c(0.4,1), log="y", cex.axis=0.8)
text(52, pr2.1[51], "amplification",
adj=c(1,-0.5), cex=0.8)
maxamp(Lrub1)
reac(Lrub1,bound = "upper")
inertia(Lrub1,bound = "lower")
plot(pr2.1, ylim=c(0.4,1), log="y", cex.axis=0.8)
text(52, pr2.1[51], "amplification",
adj=c(1,-0.5), cex=0.8)
maxamp(Lrub1)
reac(Lrub1,bound = "upper")
inertia(Lrub1,bound = "lower")
plot(pr2.1, ylim=c(0.4,1), log="y", cex.axis=0.8)
text(52, pr2.1[51], "attenuation",
adj=c(1,-0.5), cex=0.8)
maxamp(Lrub1, )
reac(Lrub1,bound = "upper")
inertia(Lrub1,bound = "lower")
reac <- reactivity(Lrub1, vector=n0.amp)
maxamp <- maxamp(Lrub1, vector=n0.amp, return.t=T)
maxamp <- maxamp(Lrub1,  return.t=T)
maxamp
upinertia <- inertia(Lrub1, vector=n0.amp)
reac <- reactivity(Lrub1, vector=n0.amp)
maxamp <- maxamp(Lrub1,  return.t=T)
upinertia <- inertia(Lrub1, vector=n0.amp)
reac <- reac(Lrub1, vector=n0.amp)
reac <- reac(Lrub1, vector=n0.amp)
maxamp <- maxamp(Lrub1,  return.t=T)
upinertia <- inertia(Lrub1, vector=n0.amp)
points(c(1,maxamp$t,31), c(reac,maxamp$maxamp,upinertia),
pch=3, col="red")
par(mar=c(10,4,1,1))
points(c(1,maxamp$t,31), c(reac,maxamp$maxamp,upinertia),
pch=3, col="red")
pr2.1 <- project(Lrub1, vector=n0.amp, time=156,
standard.A=T, standard.vec=T)
pr2.2 <- project(Lrub1, vector=n0.att, time=156,
standard.A=T, standard.vec=T)
plot(pr2.1, ylim=c(0.4,1), log="y", cex.axis=0.8)
text(52, pr2.1[51], "attenuation",
adj=c(1,-0.5), cex=0.8)
maxamp(Lrub1 )
reac(Lrub1,bound = "upper")
inertia(Lrub1,bound = "lower")
