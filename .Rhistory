# and keep filling it in...
TMat[,1] <- c(0,0.3,0)          # fill in the entire first column of the transition matrix
TMat[,2] <- c(0,0.4,0.1)        # fill in the entire second column of the transition matrix
TMat[,3] <- c(4,0,0.85)         # fill in the entire third column of the transition matrix
TMat
######
# specify initial abundance vector
InitAbund <- c(40,0,0)
names(InitAbund) <- colnames(TMat)
InitAbund
#######
# Run the model for 40 years (using for loop)
nYears <- 40
allYears <- matrix(0,nrow=nrow(TMat),ncol=nYears+1)
rownames(allYears) <- rownames(TMat)
colnames(allYears) <- seq(0,nYears)
allYears[,1] <- InitAbund
for(t in 2:(nYears+1)){
allYears[,t] <-  TMat %*% allYears[,t-1]
}
allYears
#####
# and plot out the results!
plot(1,1,pch="",ylim=c(0,50),xlim=c(0,nYears+1),xlab="Years",ylab="Abundance",xaxt="n")
cols <- rainbow(3)
for(s in 1:3){
points(allYears[s,],col=cols[s],type="l",lwd=2)
}
axis(1,at=seq(1,nYears+1),labels = seq(0,nYears))
legend("topleft",col=cols,lwd=rep(2,3),legend=rownames(allYears))
########
# Use a for loop to project the population dynamics for the next 10 years!
nYears <- 10
tenYears <- matrix(0,nrow=6,ncol=nYears+1)          # initialize storate array for recording age structured abundances for the next 10 years.
rownames(tenYears) <- rownames(Initial_teasel)      # assign row and column names
colnames(tenYears) <- seq(0,10)
tenYears[,1] <- Initial_teasel                      # initialize the simulated abundances
##########
# run the for loop!
for(t in 2:(nYears+1)){    # here we use 't' as our looping variable, but we could choose any name we want
tenYears[,t] <-  teasel_matrix %*% tenYears[,t-1]     # perform matrix multiplication for each year of the simulation!
}
tenYears
#########
# Plot the projected population trajectory over the next 10 years
plot(1,1,pch="",ylim=c(0,60000000),xlim=c(0,11),xlab="Years",ylab="Abundance",xaxt="n")    # make empty plot
cols <- rainbow(6)        # set colors for each stage
for(s in 1:6){
points(tenYears[s,],col=cols[s],type="l",lwd=2)       # plot out each stage
}
axis(1,at=seq(1,11),labels = seq(0,10))      # add x axis labels
legend("topleft",col=cols,lwd=rep(2,6),legend=rownames(tenYears))      # add legend
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
#####
# fill in the top left element of the matrix
TMat[1,1] <- 0
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
############################################################
####                                                    ####
####  BIOL4558, Topico 7                               ####
####                                                    ####
####  Kevin Shoemaker                                   ####
####  University of Nevada, Reno                    ####
####        &                           ####
####  Raymond L. Tremblay       ####
####  Universidad de Puerto Rico                   ####
####                                                    ####
############################################################
############################################################
####  Matrix population models                          ####
############################################################
#########
# Teasel example from Gotelli: summarizing a complex life history!
teasel <- read.csv("teaselmatrix1.csv", header=T)      # read in the teasel transition matrix from Gotelli
teasel <- teasel[,-1]                                  # remove the row names
teasel_matrix <- as.matrix(teasel)                     # convert to a matrix (from a data frame)
colnames(teasel_matrix) <- names(teasel)               # assign row and column names
rownames(teasel_matrix) <- names(teasel)
teasel_matrix                                          # print the matrix
#############
# Summarize initial age-structured abundance as a matrix with one column
Initial_teasel <- matrix(c(1000,1500,200,300,600,25),ncol=1)         # initial population size (population vector; matrix with 1 column!)
rownames(Initial_teasel) <- rownames(teasel_matrix)                  # add row and column names
colnames(Initial_teasel) <- "Abundance"
Initial_teasel
#########
# Project the population at time 1
Year1 <- teasel_matrix %*% Initial_teasel   # note: the '%*%' denotes 'matrix multiplication' in R. We'll go through this more later.
Year1
#########
# Project the population at time 2
thisYear <- Year1
nextYear <- teasel_matrix %*% thisYear
nextYear  # now we get the (age structured) population size at time 2!
########
# Use a for loop to project the population dynamics for the next 10 years!
nYears <- 10
tenYears <- matrix(0,nrow=6,ncol=nYears+1)          # initialize storate array for recording age structured abundances for the next 10 years.
rownames(tenYears) <- rownames(Initial_teasel)      # assign row and column names
colnames(tenYears) <- seq(0,10)
tenYears[,1] <- Initial_teasel                      # initialize the simulated abundances
##########
# run the for loop!
for(t in 2:(nYears+1)){    # here we use 't' as our looping variable, but we could choose any name we want
tenYears[,t] <-  teasel_matrix %*% tenYears[,t-1]     # perform matrix multiplication for each year of the simulation!
}
tenYears
#########
# Plot the projected population trajectory over the next 10 years
plot(1,1,pch="",ylim=c(0,60000000),xlim=c(0,11),xlab="Years",ylab="Abundance",xaxt="n")    # make empty plot
cols <- rainbow(6)        # set colors for each stage
for(s in 1:6){
points(tenYears[s,],col=cols[s],type="l",lwd=2)       # plot out each stage
}
axis(1,at=seq(1,11),labels = seq(0,10))      # add x axis labels
legend("topleft",col=cols,lwd=rep(2,6),legend=rownames(tenYears))      # add legend
###########
#  Utilice la matriz de transición para calcular Lambda, o la tasa finita de crecimiento de la población.
Lambda <- as.numeric(round(eigen(teasel_matrix)$values[1],2))
Lambda
library(popbio)      # or... it's easier to use the 'popbio' library in R!
lambda(teasel_matrix)
##########
# Compute stable age distribution from the transition matrix!
SAD <- abs(as.numeric(round(eigen(teasel_matrix)$vectors[,1],3)))
SAD/sum(SAD)      # stable age distribution as a percentage of the total population
library(popbio)    # ... and it's even easier if we use the 'popbio' package...
stable.stage(teasel_matrix)
###################
# In class demo: convert an insightmaker model to a matrix projection model
###########
# First, we specify a blank transition matrix
TMat <- matrix(0,nrow=3,ncol=3)                    # create a blank matrix with 3 rows and 3 columns
stagenames <- c("Juveniles","Subadults","Adults")  # name the rows and columns
rownames(TMat) <- stagenames
colnames(TMat) <- stagenames
TMat                                               # now we have an all-zero transition matrix.
#####
# fill in the top left element of the matrix
TMat[1,1] <- 0
TMat
#####
# update the second row, first column
TMat[2,1] <- 0.3
TMat
#####
# and keep filling it in...
TMat[,1] <- c(0,0.3,0)          # fill in the entire first column of the transition matrix
TMat[,2] <- c(0,0.4,0.1)        # fill in the entire second column of the transition matrix
TMat[,3] <- c(4,0,0.85)         # fill in the entire third column of the transition matrix
TMat
######
# specify initial abundance vector
InitAbund <- c(40,0,0)
names(InitAbund) <- colnames(TMat)
InitAbund
#######
# Run the model for 40 years (using for loop)
nYears <- 40
allYears <- matrix(0,nrow=nrow(TMat),ncol=nYears+1)
rownames(allYears) <- rownames(TMat)
colnames(allYears) <- seq(0,nYears)
allYears[,1] <- InitAbund
for(t in 2:(nYears+1)){
allYears[,t] <-  TMat %*% allYears[,t-1]
}
allYears
#####
# and plot out the results!
plot(1,1,pch="",ylim=c(0,50),xlim=c(0,nYears+1),xlab="Years",ylab="Abundance",xaxt="n")
cols <- rainbow(3)
for(s in 1:3){
points(allYears[s,],col=cols[s],type="l",lwd=2)
}
axis(1,at=seq(1,nYears+1),labels = seq(0,nYears))
legend("topleft",col=cols,lwd=rep(2,3),legend=rownames(allYears))
###################
# In class demo: convert an insightmaker model to a matrix projection model
###########
# First, we specify a blank transition matrix
TMat <- matrix(0,nrow=3,ncol=3)                    # create a blank matrix with 3 rows and 3 columns
stagenames <- c("Juveniles","Subadults","Adults")  # name the rows and columns
rownames(TMat) <- stagenames
colnames(TMat) <- stagenames
TMat                                               # now we have an all-zero transition matrix.
#####
# fill in the top left element of the matrix
TMat[1,1] <- 0
TMat
#####
# update the second row, first column
TMat[2,1] <- 0.3
TMat
library(popbio)      # or... it's easier to use the 'popbio' library in R!
lambda(teasel_matrix)
#####
# and plot out the results!
plot(1,1,pch="",ylim=c(0,50),xlim=c(0,nYears+1),xlab="Years",ylab="Abundance",xaxt="n")
cols <- rainbow(3)
for(s in 1:3){
points(allYears[s,],col=cols[s],type="l",lwd=2)
}
axis(1,at=seq(1,nYears+1),labels = seq(0,nYears))
legend("topleft",col=cols,lwd=rep(2,3),legend=rownames(allYears))
install.packages(c("bayestestR", "bslib", "cachem", "caret", "cubature", "DEoptimR", "distillery", "e1071", "effectsize", "emmeans", "extRemes", "fansi", "fitdistrplus", "forecast", "formatR", "ggside", "gt", "hms", "htmlTable", "huxtable", "inline", "insight", "ks", "lme4", "manipulateWidget", "Matrix", "matrixStats", "mgcv", "MultinomialCI", "naniar", "parameters", "performance", "pillar", "plot3D", "precrec", "rankFD", "RcppArmadillo", "rsconnect", "rversions", "sandwich", "sass", "shape", "sjmisc", "sjPlot", "spdep", "statmod", "stringi", "tibble", "timereg", "tinytex", "unmarked", "WikidataR", "xaringan", "xfun", "zip"))
R.version
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
R.version
install.packages(c("Matrix", "mgcv"))
install.packages("knitr", dependencies = TRUE)
install.packages("knitr", dependencies = TRUE)
install.packages("knitr", dependencies = TRUE)
install.packages("knitr", dependencies = TRUE)
install.packages("knitr", dependencies = TRUE)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
#############
# Generación de números aleatorios!
#####
# define an arbitrary distribution
box <- c(rep(1,10),rep(2,5),rep(3,2))                                           # define what's in the lottery ball machine (10 "1" balls, 5 "2" balls and 2 "3" balls)
barplot(table(box)/sum(table(box)),ylab="probability",xlab="possibility")       # visualize the distribution of possibilities
#############
# Generación de números aleatorios!
#####
# define an arbitrary distribution
box <- c(rep(1,10),rep(2,5),rep(3,2))                                           # define what's in the lottery ball machine (10 "1" balls, 5 "2" balls and 2 "3" balls)
barplot(table(box)/sum(table(box)),ylab="probability",xlab="possibility")       # visualize the distribution of possibilities
#############
# Generación de números aleatorios!
#####
# define an arbitrary distribution
box <- c(rep(1,10),rep(2,5),rep(3,2))                                           # define what's in the lottery ball machine (10 "1" balls, 5 "2" balls and 2 "3" balls)
barplot(table(box)/sum(table(box)),ylab="probability",xlab="possibility")       # visualize the distribution of possibilities
################
# Distribuciones discretas
################
#######
# Ejemplo: distribución binomial (distribución de lanzamiento de moneda)
# plot a discrete distribution!
xvals <- seq(0,10,1)
probs <- dbinom(xvals,10,prob=0.3)
names(probs) <- xvals
barplot(probs,ylab="Probability",xlab="Possibilities",main="Binomial distribution (discrete)")
################
# DISTRIBUCIONES CONTINUAS
#################
##########
# Distribución uniforme
lower = 0
upper = 10
curve(dunif(x,lower,upper),0,10,ylab="Probability (density)",xlab="Possibilities",main="Uniform distribution (continuous)",ylim=c(0,1))   # probability density
############
# Log-normal distribution
meanlog = 1.4
stdevlog = 0.6
curve(dlnorm(x,meanlog,stdevlog),0,15,ylab="Probability (density)",xlab="Possibilities",main="Lognormal distribution (continuous)")   # probability density
################
# Random number generation!
### Binomial random number generator
rbinom(1,size=10,prob=0.5)    # note: "size" is the number of coin flips, and "prob" is the probability of coming up 'heads'
### Poisson random number generator
rpois(1,lambda=4.1)     # note: "lambda" represents the mean (and variance!) of the Poisson distribution
### Uniform random number generator
runif(1,min=1,max=3.5)   # "min" and "max" are pretty obvious!
### Normal random number generator
rnorm(1,mean=3,sd=4.1)   # normal distribution is defined by "mean" and "sd" (standard deviation).
### lognormal random number generator (like normal distribution, but can not go below zero)
rlnorm(1,meanlog=0.5,sdlog=0.2)    # lognormal distribution is defined by "meanlog", the mean on the log scale and "sdlog" (standard deviation on the log scale).
### beta random number generator (bounded between 0 and 1- just like survival rate!)
rbeta(1,shape1=10,shape2=3)  # beta distribution is defined by "shape1" and "shape2", which together define the mean and spread within the range from 0 to 1.
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
df <- data.frame(
Vital_Rate = c("Surv","Surv","Fec","Fec"),
sex = c("F","M","F (daughters)","M (sons)"),
CV = c(0.111,0.185,0.350, 0.291),
min_CV = c(0.102,0.136,0.303,0.268),
max_CV = c(0.119,0.201,0.376,0.331)
)
df
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
lifetable <- read.csv("life_table.csv")
knitr::kable(lifetable,caption="",col.names = c("x","S(x)","b(x)","l(x)","g(x)"))
knitr::opts_chunk$set(echo = TRUE)
library('popbio')
library('popdemo')
#library('modeest')
#matrices of transitions for sub-population 1
popState <- c(13, 16, 2, 19) #vector of sub-population 1 abundances for last year of observations
transMat    <- list() #matrix of transitions
transMat$T1 <- rbind(c(0.7869273, 0, 0.8300450, 0), c(0.1760353, 0.97248154, 0, 0), c(0, 0.01578038, 0.5746824, 0.07676408), c(0, 0, 0.4162108, 0.92323588))
transMat$T2 <- rbind(c(0.8285143, 0, 5.542540e-10 , 0), c(0.1396047, 0.96356898, 0, 0), c(0, 0.02150297, 0.4921383, 0.08007071), c(0, 0, 0.4983780, 0.91992925))
transMat$T3 <- rbind(c(0.8503599, 0, 5.636965e-10 , 0), c(0.1052920, 0.96467304, 0, 0), c(0, 0.01998974, 0.4835024, 0.08807574), c(0, 0, 0.5073186, 0.91192422))
transMat$T4 <- rbind(c(0.90264580, 0, 5.235940e-10, 0), c(0.06590077, 0.9630270, 0, 0), c(0, 0.0208872, 0.5139655, 0.08746788), c(0, 0, 0.4768932, 0.91253208))
transMat$T5 <- rbind(c(0.91771803, 0, 0.3499083, 0), c(0.05391462, 0.97005810, 0, 0), c(0, 0.01632058, 0.4419389, 0.07880436), c(0, 0, 0.5489797, 0.92119559))
transMat$T6 <- rbind(c(0.87316400, 0, 1.687415e-10, 0), c(0.08590074, 0.95334666, 0, 0), c(0, 0.02579743, 4.139104e-01, 0.08205262), c(0, 0, 5.766711e-01, 0.91794733))
transMat$T7 <- rbind(c(0.90703646, 0, 6.906485e-10, 0), c(0.06060516, 0.96867738, 0, 0), c(0, 0.01777129, 4.849267e-01, 0.07774181), c(0, 0, 5.058289e-01, 0.92225814))
transMat$T8 <- rbind(c(0.93404923, 0, 3.449700e-10, 0), c(0.04564076, 0.97236335, 0, 0), c(0, 0.01519189, 4.806209e-01, 0.07931822), c(0, 0, 5.101786e-01, 0.92068174))
transMat$T9 <- rbind(c(0.88524275, 0, 1.565175e-10, 0), c(0.07985631, 0.9613211, 0, 0), c(0, 0.0211242, 3.741810e-01, 0.08446428), c(0, 0, 6.166460e-01, 0.91553567))
transMat$T10 <- rbind(c(0.91569045, 0, 3.667075e-10, 0), c(0.05907888, 0.97480231, 0, 0), c(0, 0.01365979, 5.778412e-01, 0.07328772), c(0, 0, 4.130556e-01, 0.92671224))
transMat$T11 <- rbind(c(0.9170242, 0, 3.657935e-10, 0), c(0.0573607, 0.97434500, 0, 0), c(0, 0.01424255, 4.055471e-01, 0.07605183), c(0, 0, 5.854003e-01, 0.92394813))
transMat$T12 <- rbind(c(0.91868350, 0, 8.395985e-10, 0), c(0.05698844, 0.97126869, 0, 0), c(0, 0.01620411, 4.599883e-01, 0.07786934), c(0, 0, 5.308060e-01, 0.92213062))
transMat$T13 <- rbind(c(0.8933651, 0, 0.4218637, 0), c(0.0754819, 0.96883951, 0, 0), c(0, 0.01741538, 0.4741468, 0.08011046), c(0, 0, 0.5166038, 0.91988950))
transMat$T14 <- rbind(c(0.8941097, 0, 4.074855e-10, 0), c(0.0751373, 0.96842970, 0, 0), c(0, 0.01771008, 4.739166e-01, 0.07977865), c(0, 0, 5.167966e-01, 0.92022130))
transMat$T15 <- rbind(c(0.89332212, 0, 4.823470e-10, 0), c(0.07570813, 0.96829439, 0, 0), c(0, 0.01776341, 4.761405e-01, 0.08013242), c(0, 0, 5.145436e-01, 0.91986753))
transMat$T16 <- rbind(c(0.89225132, 0, 5.007945e-10, 0), c(0.07662393, 0.96863160, 0, 0), c(0, 0.01747498, 4.780552e-01, 0.08001434), c(0, 0, 5.126394e-01, 0.91998562))
transMat$T17 <- rbind(c(0.89289170, 0, 0.9053583, 0), c(0.07597438, 0.96813832, 0, 0), c(0, 0.01785388, 0.4746140, 0.08009411), c(0, 0, 0.5160928, 0.91990584))
transMat$T18 <- rbind(c(0.89225811, 0, 2.24541e-10, 0), c(0.07655306, 0.96828614, 0, 0), c(0, 0.01768011, 4.74461e-01, 0.07999146), c(0, 0, 5.16246e-01, 0.92000850))
transMat$T19 <- rbind(c(0.89225811, 0, 2.24541e-10, 0), c(0.07655306, 0.96828614, 0, 0), c(0, 0.01768011, 4.74461e-01, 0.07999146), c(0, 0, 5.16246e-01, 0.92000850))
transMat$T20 <- rbind(c(0.89279674, 0, 11.7187000, 0), c(0.07637371, 0.96860413, 0, 0), c(0, 0.01752984, 0.4744193, 0.08030667), c(0, 0, 0.5162513, 0.91969328))
transMat$T21 <- rbind(c(0.89453969, 0, 0.1771410, 0), c(0.07457337, 0.96833046, 0, 0), c(0, 0.01773764, 0.4751942, 0.07996677), c(0, 0, 0.5155116, 0.92003319))
transMat$T22 <- rbind(c(0.89360562, 0, 2.087290e-10, 0), c(0.07532944, 0.96833477, 0, 0), c(0, 0.01768248, 4.714852e-01, 0.08010061), c(0, 0, 5.192556e-01, 0.91989934))
transMat$T23 <- rbind(c(0.8920189, 0, 3.928490e-10, 0), c(0.0768873, 0.96852428, 0, 0), c(0, 0.01750726, 4.745888e-01, 0.07982504), c(0, 0, 5.161487e-01, 0.92017492))
transMat$T24 <- rbind(c(0.89387344, 0, 0.3548790, 0), c(0.07528274, 0.96816469, 0, 0), c(0, 0.01784024, 0.4740048, 0.08062855), c(0, 0, 0.5167163, 0.91937140))
#calculate the average transition matrix
meanT 	= mean(transMat)
print(meanT)
sdT 	= sqrt(var2(transMat))
print(sdT)
lambda 	= lambda(meanT)
cat('lambda', lambda, '\n')
ss 		= stable.stage(meanT)
cat('stable stage', ss, '\n')
rv 		= reproductive.value(meanT)
cat('reproductive value', rv, '\n')
elas 	= elasticity(meanT)
cat('elasticity', '\n')
print(elas)
cat('transfer function analysis',  '\n')
ele.mat <- matrix(NA, 4,4)
ele.mat[1,3] <- "F"
ele.mat[1,1] <- "P"
ele.mat[2,1] <- "P"
ele.mat[2,2] <- "P"
ele.mat[3,2] <- "P"
ele.mat[3,3] <- "P"
ele.mat[4,3] <- "P"
ele.mat[3,4] <- "P"
ele.mat[4,4] <- "P"
par(mfrow=c(4,4))
par(mar=c(4.1, 4.1, 1.1, 1.1))
zeros <- c(0, 0, 0, 0)
for(i in 1:4) {
for(j in 1:4) {
if(meanT[i,j] <= 1e-10) {
plot(0,xaxt='n',yaxt='n',bty='n',pch='',ylab='',xlab='')
next()
}
d1 	  <- e1 <- zeros
d1[i] <- 1
e1[j] <- 1
delta <- 1*seq(-meanT[i,j], meanT[i,j], 0.01)
tf1 <- tfa_lambda(meanT, d = d1, e = e1, prange = delta)
plot(tf1)#, xlab="Perturbation", ylab=expression(lambda))
s76 <- sens(meanT)[i, j]
abline(eigs(meanT, "lambda"), s76, lty = 2)
}
}
popSGR 			= stoch.growth.rate(transMat, verbose=F)
lambdaCI 		= list()
lambdaCI$approx	= exp(popSGR$approx)
lambdaCI$sim 	= exp(popSGR$sim)
lambdaCI$sim.CI	= exp(popSGR$sim.CI)
cat('lambda\n')
print(lambdaCI)
#Runs the projections. nreps is the number of replications. Takes awhile to run
popProject	= stoch.projection(matrices=transMat, n0=popState, tmax=240, nmax=1000, nreps=1e4, prob=rep(1/24, length=24), verbose=FALSE)
totPopSize 	= apply(popProject, 1, sum)
hist(totPopSize, breaks=100, col="black", border="white", xlab="Final population size at t=240 (24 years)", main='Sub-population 1')
graphics.off()
#mlvPop = mlv(totPopSize, method = "naive")
extin=c()
popQuant = matrix(NA, 3, 241)
popQuant[,1] = rep(sum(popState), 3)
popMean	= vector('numeric', 241)
popMean[1] = sum(popState)
popSD	= vector('numeric', 241)
popSD[1] = NA
for(i in 1:240){
matriz=c()
interactionX=100000
quasi=2
popExtinctProject<-stoch.projection(matrices=transMat, n0=popState, tmax=i, nmax=1000, nreps = interactionX, prob = rep(1/24, length=24), verbose=FALSE)
for(ii in 1:interactionX){
a=sum(popExtinctProject[ii,])
matriz<-rbind(matriz,c(a))
}
vv=matriz[matriz<quasi]
s=length(vv)
extin=c(extin,s)
popQuant[,i+1] <- quantile(apply(popExtinctProject, 1, sum), probs=c(0.025, 0.5, 0.975))
popMean[i+1] 	= mean(apply(popExtinctProject, 1, sum))
popSD[i+1] 		= sd(apply(popExtinctProject, 1, sum))
}
library('popbio')
library('popdemo')
#library('modeest')
#matrices of transitions for sub-population 1
popState <- c(13, 16, 2, 19) #vector of sub-population 1 abundances for last year of observations
transMat    <- list() #matrix of transitions
transMat$T1 <- rbind(c(0.7869273, 0, 0.8300450, 0), c(0.1760353, 0.97248154, 0, 0), c(0, 0.01578038, 0.5746824, 0.07676408), c(0, 0, 0.4162108, 0.92323588))
transMat$T2 <- rbind(c(0.8285143, 0, 5.542540e-10 , 0), c(0.1396047, 0.96356898, 0, 0), c(0, 0.02150297, 0.4921383, 0.08007071), c(0, 0, 0.4983780, 0.91992925))
transMat$T3 <- rbind(c(0.8503599, 0, 5.636965e-10 , 0), c(0.1052920, 0.96467304, 0, 0), c(0, 0.01998974, 0.4835024, 0.08807574), c(0, 0, 0.5073186, 0.91192422))
transMat$T4 <- rbind(c(0.90264580, 0, 5.235940e-10, 0), c(0.06590077, 0.9630270, 0, 0), c(0, 0.0208872, 0.5139655, 0.08746788), c(0, 0, 0.4768932, 0.91253208))
transMat$T5 <- rbind(c(0.91771803, 0, 0.3499083, 0), c(0.05391462, 0.97005810, 0, 0), c(0, 0.01632058, 0.4419389, 0.07880436), c(0, 0, 0.5489797, 0.92119559))
transMat$T6 <- rbind(c(0.87316400, 0, 1.687415e-10, 0), c(0.08590074, 0.95334666, 0, 0), c(0, 0.02579743, 4.139104e-01, 0.08205262), c(0, 0, 5.766711e-01, 0.91794733))
transMat$T7 <- rbind(c(0.90703646, 0, 6.906485e-10, 0), c(0.06060516, 0.96867738, 0, 0), c(0, 0.01777129, 4.849267e-01, 0.07774181), c(0, 0, 5.058289e-01, 0.92225814))
transMat$T8 <- rbind(c(0.93404923, 0, 3.449700e-10, 0), c(0.04564076, 0.97236335, 0, 0), c(0, 0.01519189, 4.806209e-01, 0.07931822), c(0, 0, 5.101786e-01, 0.92068174))
transMat$T9 <- rbind(c(0.88524275, 0, 1.565175e-10, 0), c(0.07985631, 0.9613211, 0, 0), c(0, 0.0211242, 3.741810e-01, 0.08446428), c(0, 0, 6.166460e-01, 0.91553567))
transMat$T10 <- rbind(c(0.91569045, 0, 3.667075e-10, 0), c(0.05907888, 0.97480231, 0, 0), c(0, 0.01365979, 5.778412e-01, 0.07328772), c(0, 0, 4.130556e-01, 0.92671224))
transMat$T11 <- rbind(c(0.9170242, 0, 3.657935e-10, 0), c(0.0573607, 0.97434500, 0, 0), c(0, 0.01424255, 4.055471e-01, 0.07605183), c(0, 0, 5.854003e-01, 0.92394813))
transMat$T12 <- rbind(c(0.91868350, 0, 8.395985e-10, 0), c(0.05698844, 0.97126869, 0, 0), c(0, 0.01620411, 4.599883e-01, 0.07786934), c(0, 0, 5.308060e-01, 0.92213062))
transMat$T13 <- rbind(c(0.8933651, 0, 0.4218637, 0), c(0.0754819, 0.96883951, 0, 0), c(0, 0.01741538, 0.4741468, 0.08011046), c(0, 0, 0.5166038, 0.91988950))
transMat$T14 <- rbind(c(0.8941097, 0, 4.074855e-10, 0), c(0.0751373, 0.96842970, 0, 0), c(0, 0.01771008, 4.739166e-01, 0.07977865), c(0, 0, 5.167966e-01, 0.92022130))
transMat$T15 <- rbind(c(0.89332212, 0, 4.823470e-10, 0), c(0.07570813, 0.96829439, 0, 0), c(0, 0.01776341, 4.761405e-01, 0.08013242), c(0, 0, 5.145436e-01, 0.91986753))
transMat$T16 <- rbind(c(0.89225132, 0, 5.007945e-10, 0), c(0.07662393, 0.96863160, 0, 0), c(0, 0.01747498, 4.780552e-01, 0.08001434), c(0, 0, 5.126394e-01, 0.91998562))
transMat$T17 <- rbind(c(0.89289170, 0, 0.9053583, 0), c(0.07597438, 0.96813832, 0, 0), c(0, 0.01785388, 0.4746140, 0.08009411), c(0, 0, 0.5160928, 0.91990584))
transMat$T18 <- rbind(c(0.89225811, 0, 2.24541e-10, 0), c(0.07655306, 0.96828614, 0, 0), c(0, 0.01768011, 4.74461e-01, 0.07999146), c(0, 0, 5.16246e-01, 0.92000850))
transMat$T19 <- rbind(c(0.89225811, 0, 2.24541e-10, 0), c(0.07655306, 0.96828614, 0, 0), c(0, 0.01768011, 4.74461e-01, 0.07999146), c(0, 0, 5.16246e-01, 0.92000850))
transMat$T20 <- rbind(c(0.89279674, 0, 11.7187000, 0), c(0.07637371, 0.96860413, 0, 0), c(0, 0.01752984, 0.4744193, 0.08030667), c(0, 0, 0.5162513, 0.91969328))
transMat$T21 <- rbind(c(0.89453969, 0, 0.1771410, 0), c(0.07457337, 0.96833046, 0, 0), c(0, 0.01773764, 0.4751942, 0.07996677), c(0, 0, 0.5155116, 0.92003319))
transMat$T22 <- rbind(c(0.89360562, 0, 2.087290e-10, 0), c(0.07532944, 0.96833477, 0, 0), c(0, 0.01768248, 4.714852e-01, 0.08010061), c(0, 0, 5.192556e-01, 0.91989934))
transMat$T23 <- rbind(c(0.8920189, 0, 3.928490e-10, 0), c(0.0768873, 0.96852428, 0, 0), c(0, 0.01750726, 4.745888e-01, 0.07982504), c(0, 0, 5.161487e-01, 0.92017492))
transMat$T24 <- rbind(c(0.89387344, 0, 0.3548790, 0), c(0.07528274, 0.96816469, 0, 0), c(0, 0.01784024, 0.4740048, 0.08062855), c(0, 0, 0.5167163, 0.91937140))
#calculate the average transition matrix
meanT 	= mean(transMat)
print(meanT)
sdT 	= sqrt(var2(transMat))
print(sdT)
lambda 	= lambda(meanT)
cat('lambda', lambda, '\n')
ss 		= stable.stage(meanT)
cat('stable stage', ss, '\n')
rv 		= reproductive.value(meanT)
cat('reproductive value', rv, '\n')
elas 	= elasticity(meanT)
cat('elasticity', '\n')
print(elas)
cat('transfer function analysis',  '\n')
ele.mat <- matrix(NA, 4,4)
ele.mat[1,3] <- "F"
ele.mat[1,1] <- "P"
ele.mat[2,1] <- "P"
ele.mat[2,2] <- "P"
ele.mat[3,2] <- "P"
ele.mat[3,3] <- "P"
ele.mat[4,3] <- "P"
ele.mat[3,4] <- "P"
ele.mat[4,4] <- "P"
par(mfrow=c(4,4))
par(mar=c(4.1, 4.1, 1.1, 1.1))
zeros <- c(0, 0, 0, 0)
for(i in 1:4) {
for(j in 1:4) {
if(meanT[i,j] <= 1e-10) {
plot(0,xaxt='n',yaxt='n',bty='n',pch='',ylab='',xlab='')
next()
}
d1 	  <- e1 <- zeros
d1[i] <- 1
e1[j] <- 1
delta <- 1*seq(-meanT[i,j], meanT[i,j], 0.01)
tf1 <- tfa_lambda(meanT, d = d1, e = e1, prange = delta)
plot(tf1)#, xlab="Perturbation", ylab=expression(lambda))
s76 <- sens(meanT)[i, j]
abline(eigs(meanT, "lambda"), s76, lty = 2)
}
}
popSGR 			= stoch.growth.rate(transMat, verbose=F)
lambdaCI 		= list()
lambdaCI$approx	= exp(popSGR$approx)
lambdaCI$sim 	= exp(popSGR$sim)
lambdaCI$sim.CI	= exp(popSGR$sim.CI)
cat('lambda\n')
print(lambdaCI)
#Runs the projections. nreps is the number of replications. Takes awhile to run
popProject	= stoch.projection(matrices=transMat, n0=popState, tmax=240, nmax=1000, nreps=1e4, prob=rep(1/24, length=24), verbose=FALSE)
totPopSize 	= apply(popProject, 1, sum)
hist(totPopSize, breaks=100, col="black", border="white", xlab="Final population size at t=240 (24 years)", main='Sub-population 1')
graphics.off()
#mlvPop = mlv(totPopSize, method = "naive")
extin=c()
popQuant = matrix(NA, 3, 241)
popQuant[,1] = rep(sum(popState), 3)
popMean	= vector('numeric', 241)
popMean[1] = sum(popState)
popSD	= vector('numeric', 241)
popSD[1] = NA
for(i in 1:240){
matriz=c()
interactionX=1000
quasi=2
popExtinctProject<-stoch.projection(matrices=transMat, n0=popState, tmax=i, nmax=1000, nreps = interactionX, prob = rep(1/24, length=24), verbose=FALSE)
for(ii in 1:interactionX){
a=sum(popExtinctProject[ii,])
matriz<-rbind(matriz,c(a))
}
vv=matriz[matriz<quasi]
s=length(vv)
extin=c(extin,s)
popQuant[,i+1] <- quantile(apply(popExtinctProject, 1, sum), probs=c(0.025, 0.5, 0.975))
popMean[i+1] 	= mean(apply(popExtinctProject, 1, sum))
popSD[i+1] 		= sd(apply(popExtinctProject, 1, sum))
}
plot(popMean, xlab="Time (months)", ylab="Number of individuals (n)", type='l', main="Sub-pop 1", lwd=2, ylim=c(0,max(popQuant, na.rm=T)))
lines(popQuant[1,])
lines(popQuant[3,])
graphics.off()
plot(extin/interactionX, type='l', lwd=2, xlab="Months into future", main="Extinction probability for sub-population 1")
install.packages(c("ade4", "broom", "car", "colorspace", "cpp11", "curl", "cutpointr", "DescTools", "dplyr", "furrr", "gert", "GGally", "ggplot2", "insight", "lme4", "mime", "openxlsx", "plotly", "psych", "raster", "rio", "rmarkdown", "RVAideMemoire", "testthat", "xfun"))
install.packages(c("ade4", "broom", "car", "colorspace", "cpp11", "curl", "cutpointr", "DescTools", "dplyr", "furrr", "gert", "GGally", "ggplot2", "insight", "lme4", "mime", "openxlsx", "plotly", "psych", "raster", "rio", "rmarkdown", "RVAideMemoire", "testthat", "xfun"))
install.packages(c("ade4", "broom", "car", "colorspace", "cpp11", "curl", "cutpointr", "DescTools", "dplyr", "furrr", "gert", "GGally", "ggplot2", "insight", "lme4", "mime", "openxlsx", "plotly", "psych", "raster", "rio", "rmarkdown", "RVAideMemoire", "testthat", "xfun"))
